<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon shortcut" type="image/png" href="https://blog.ubie.tech/logo.png"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap"/><title>jimbo | Ubie Engineers&#x27; Blogs</title><meta property="og:title" content="jimbo"/><meta property="og:url" content="https://blog.ubie.tech/members/jimbo"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:site" content="Ubie Engineers&#x27; Blogs"/><meta property="og:image" content="https://blog.ubie.tech/og.png"/><link rel="canonical" href="https://blog.ubie.tech/members/jimbo"/><link rel="preload" href="/_next/static/css/5b1e5c056c67d836f701.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5b1e5c056c67d836f701.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-8a83f0fd99327c4684a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8d61253ae98ee51657b8.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-49079e3278dd6cef7229.js" as="script"/><link rel="preload" href="/_next/static/chunks/81b50c7ab23905e464b4340eb234bd6ea389d26b.dccc213aaaf4627fbcd3.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/members/%5Bid%5D-f279413a3daf3c18264d.js" as="script"/></head><body><div id="__next"><header class="site-header"><div class="content-wrapper"><div class="site-header__inner"><a class="site-header__logo-link" href="/"><img src="/logo.png" alt="Ubie Engineers&#x27; Blogs" class="site-header__logo-img"/><span class="site-header__logo-text">Ubie<br/>Engineers&#x27; Blogs</span></a><div class="site-header__links"><a href="https://ubie.life/" class="site-header__link" target="_blank">Company</a><a href="https://recruit.ubie.life/jd_dev" class="site-header__link" target="_blank">Recruit</a></div></div></div></header><section class="member"><div class="content-wrapper"><header class="member-header"><div class="member-header__avatar"><img src="/avatars/jimbo.png" alt="jimbo" width="100" height="100" class="member-header__avatar-img"/></div><h1 class="member-header__nickname">jimbo</h1><p class="member-header__real-name">神保嘉秀</p><p class="member-header__bio">大阪からリモートワークしてます</p><div class="member-header__links"><a href="https://twitter.com/jmblog" class="member-header__link"><img src="/icons/twitter.svg" alt="Twitterのユーザー@jmblog" width="22" height="22"/></a><a href="https://github.com/jmblog" class="member-header__link"><img src="/icons/github.svg" alt="GitHubのユーザー@jmblog" width="22" height="22"/></a><a href="https://jmblog.jp" class="member-header__link"><img src="/icons/link.svg" alt="ウェブサイトのリンク" width="22" height="22"/></a></div></header><div class="member-posts-container"><div class="post-list"><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2021-09-26T00:00:00.000Z" class="post-link__date">a month ago</time></div></a><a href="https://jmblog.jp/posts/2021-09-26/migrate-from-nuxtjs-to-nextjs" class="post-link__main-link"><h2 class="post-link__title">ブログを Nuxt.js から Next.js に移行した</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2021-09-15T00:00:00.000Z" class="post-link__date">2 months ago</time></div></a><a href="https://jmblog.jp/posts/2021-09-15/how-to-deal-with-technical-debt-in-start-up-companies" class="post-link__main-link"><h2 class="post-link__title">「0→1」フェーズにおける技術的負債との向き合い方</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2021-06-10T14:47:24.000Z" class="post-link__date">5 months ago</time></div></a><a href="https://zenn.dev/jimbo/articles/403a5d98624c1b" class="post-link__main-link"><h2 class="post-link__title">private な npm パッケージを Dockerfile でインストールして GitHub Actions でビルドする</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=zenn.dev" width="14" height="14" class="post-link__site-favicon"/>zenn.dev</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2020-12-30T00:00:00.000Z" class="post-link__date">10 months ago</time></div></a><a href="https://jmblog.jp/posts/2020-12-30/looking-back-2020" class="post-link__main-link"><h2 class="post-link__title">2020年振り返り</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2020-12-06T08:34:33.000Z" class="post-link__date">a year ago</time></div></a><a href="https://note.com/yjimbo/n/nc4fba7999c90" class="post-link__main-link"><h2 class="post-link__title">地方で暮らしながら都内のスタートアップでのびのびと働くソフトウェアエンジニアの話</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=note.com" width="14" height="14" class="post-link__site-favicon"/>note.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2019-12-30T00:00:00.000Z" class="post-link__date">2 years ago</time></div></a><a href="https://jmblog.jp/posts/2019-12-30/looking-back-2019" class="post-link__main-link"><h2 class="post-link__title">2019年振り返り</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2019-11-03T00:00:00.000Z" class="post-link__date">2 years ago</time></div></a><a href="https://jmblog.jp/posts/2019-11-03/frontend-conrefence-2019" class="post-link__main-link"><h2 class="post-link__title">FRONTEND CONFERENCE 2019 に登壇しました</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2018-02-15T00:00:00.000Z" class="post-link__date">4 years ago</time></div></a><a href="https://jmblog.jp/posts/2018-02-15/lit-html-with-shadycss" class="post-link__main-link"><h2 class="post-link__title">lit-html と ShadyCSS</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2018-01-24T00:00:00.000Z" class="post-link__date">4 years ago</time></div></a><a href="https://jmblog.jp/posts/2018-01-24/build-a-blog-with-nuxtjs-and-markdown-3" class="post-link__main-link"><h2 class="post-link__title">Nuxt.js で Markdown ベースのブログを構築する（サイトパフォーマンス編）</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2018-01-18T00:00:00.000Z" class="post-link__date">4 years ago</time></div></a><a href="https://jmblog.jp/posts/2018-01-18/build-a-blog-with-nuxtjs-and-markdown-2" class="post-link__main-link"><h2 class="post-link__title">Nuxt.js で Markdown ベースのブログを構築する（Nuxt.js 編）</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2018-01-17T00:00:00.000Z" class="post-link__date">4 years ago</time></div></a><a href="https://jmblog.jp/posts/2018-01-17/build-a-blog-with-nuxtjs-and-markdown-1" class="post-link__main-link"><h2 class="post-link__title">Nuxt.js で Markdown ベースのブログを構築する（Markdown 編）</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2018-01-10T00:00:00.000Z" class="post-link__date">4 years ago</time></div></a><a href="https://jmblog.jp/posts/2018-01-10/new-blog-with-nuxtjs" class="post-link__main-link"><h2 class="post-link__title">Nuxt.js を使ってブログを新しくした</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2017-12-05T05:22:24.000Z" class="post-link__date">4 years ago</time></div></a><a href="https://qiita.com/jimbo/items/d17a121f815236c2f55b" class="post-link__main-link"><h2 class="post-link__title">Vanilla JS や TypeScript で Custom Elements を書く際の注意点</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2017-07-24T07:07:26.000Z" class="post-link__date">4 years ago</time></div></a><a href="https://qiita.com/jimbo/items/f40188dd9e8f8a62592d" class="post-link__main-link"><h2 class="post-link__title">WebdriverIO + ヘッドレス Chromeでローカルブラウザテスト</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2016-11-25T09:12:03.000Z" class="post-link__date">5 years ago</time></div></a><a href="https://qiita.com/jimbo/items/95da1c223ad25a33ed16" class="post-link__main-link"><h2 class="post-link__title">webpack で moment.js の無駄なロケールファイルを除去する</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2016-11-04T05:54:48.000Z" class="post-link__date">5 years ago</time></div></a><a href="https://qiita.com/jimbo/items/1643523195b03f53e860" class="post-link__main-link"><h2 class="post-link__title">CI のビルド時に patch を適用する際の注意点</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2015-12-10T15:01:20.000Z" class="post-link__date">6 years ago</time></div></a><a href="https://qiita.com/jimbo/items/b347c19d935e796c2482" class="post-link__main-link"><h2 class="post-link__title">Angular 2: Component のスタイル実装と CSS のカプセル化</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2014-06-04T13:04:03.000Z" class="post-link__date">7 years ago</time></div></a><a href="https://qiita.com/jimbo/items/4a7792f5772207e1e3eb" class="post-link__main-link"><h2 class="post-link__title">Qiita Notification Favicon 機能拡張を作りました</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2013-12-06T14:54:20.000Z" class="post-link__date">8 years ago</time></div></a><a href="https://qiita.com/jimbo/items/9604f92795c24a7e8cb1" class="post-link__main-link"><h2 class="post-link__title">Taxman の紹介</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2013-07-21T10:10:52.000Z" class="post-link__date">8 years ago</time></div></a><a href="https://qiita.com/jimbo/items/a804177b1898e6379fe8" class="post-link__main-link"><h2 class="post-link__title">最も簡単なOpenSpending用のデータの作り方</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2012-12-05T00:00:00.000Z" class="post-link__date">9 years ago</time></div></a><a href="https://jmblog.jp/posts/2012-12-05/sass-if-function" class="post-link__main-link"><h2 class="post-link__title">Sass の if 関数</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2011-03-21T00:00:00.000Z" class="post-link__date">11 years ago</time></div></a><a href="https://jmblog.jp/posts/2011-03-21/innerHTML-returns-serialized-html" class="post-link__main-link"><h2 class="post-link__title">innerHTML や jQuery.html() は HTMLをそのまま取得できるわけではない</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2010-12-24T00:00:00.000Z" class="post-link__date">11 years ago</time></div></a><a href="https://jmblog.jp/posts/2010-12-24/cron-does-not-run-on-time" class="post-link__main-link"><h2 class="post-link__title">cronが設定した時間どおりに実行されない場合の対処法</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2007-09-25T00:00:00.000Z" class="post-link__date">14 years ago</time></div></a><a href="https://jmblog.jp/posts/2007-09-25/link-visited-hover-active" class="post-link__main-link"><h2 class="post-link__title">:link、:visited、:hover、:active の記述順序とその覚え方</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article><article class="post-link"><a class="post-link__author" href="/members/jimbo/"><img src="/avatars/jimbo.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">jimbo</div><time dateTime="2006-08-06T00:00:00.000Z" class="post-link__date">15 years ago</time></div></a><a href="https://jmblog.jp/posts/2006-08-06/how-to-clear-form-history-on-firefox" class="post-link__main-link"><h2 class="post-link__title">Firefoxでオートコンプリートの候補リストから削除する方法</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=jmblog.jp" width="14" height="14" class="post-link__site-favicon"/>jmblog.jp</div></a></article></div></div></div></section><footer class="site-footer"><div class="content-wrapper"><p>© <!-- -->Ubie Discovery</p></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"member":{"id":"jimbo","nickname":"jimbo","realName":"神保嘉秀","bio":"大阪からリモートワークしてます","avatarSrc":"/avatars/jimbo.png","sources":["https://jmblog.jp/atom.xml","https://qiita.com/jimbo/feed","https://zenn.dev/jimbo/feed","https://note.com/yjimbo/rss"],"twitterUsername":"jmblog","githubUsername":"jmblog","websiteUrl":"https://jmblog.jp"},"postItems":[{"title":"ブログを Nuxt.js から Next.js に移行した","contentSnippet":"2018年に Nuxt.js を使ってブログを新しくしたが、最近は仕事でも React しか触っていないので、Next.js に移行した。作業ログ：https://zenn.dev/jimbo/scraps/4226bd96c51c751日足らずで移行作業がほぼ終わり「余裕余裕」と思ってたけど、Netlify の不具合を踏んで sitemap.xml と atom.xml の生成がうまくいかないことがわかり、そこから数日ハマってしまった。時間はかかったが、おかげで remark を使った Markdown の処理に少し詳しくなれたのでよかった。パフォーマンスも上々。","link":"https://jmblog.jp/posts/2021-09-26/migrate-from-nuxtjs-to-nextjs","isoDate":"2021-09-26T00:00:00.000Z","dateMiliSeconds":1632614400000,"authorName":"jimbo","authorId":"jimbo"},{"title":"「0→1」フェーズにおける技術的負債との向き合い方","contentSnippet":"以前から「スタートアップのなかで『技術的負債』というものをどう扱うべきなのか」というテーマに対して関心が高かったのだが、今年の6月から「0→1」の新規事業に関わるようになって、自分の中でなんとなく考えがまとまりそうなので、雑に吐き出してみる。最近、社内でも「技術的負債」が話題にあがることが多く、その中で同僚のエンジニアからあがった意見も参考にしている。そもそも技術的負債とは@t_wada さんの次の記事に答えが書いてある。【翻訳】技術的負債という概念の生みの親 Ward Cunningham 自身による説明 - t-wada のブログ個人的には次のように解釈した。「手を抜いた雑なコード」は技術的負債とは呼ばない。それはただの低品質なコードである仮説検証や経験からさまざまな学びを得ることは正義そこで得た「学び」と「現状のソフトウェア」とのギャップを「技術的負債」と呼ぶこのような「学びから生まれる技術的負債」に加えて、仮説検証を最速で行うために（あとで返済する前提で）わざと作り出す「計画的な技術的負債」と呼ぶべき類の負債もあるように思う。いずれの負債も基本的にはポジティブに捉えてよいと考えている。「学びから生まれる技術的負債」はそれだけ多くの学びを得ているということだし、「計画的な技術的負債」もそれによって仮説検証を加速させることができるからだ。難しいのは、そのようにして生まれた技術的負債を「いつ」「どのように」返済していくかということだ。これらの技術的負債のほかに、特定の顧客からの要望やビジネス上のやんごとなき事情によりプロダクトに組み込まれた「大人の事情による負債」というのもありそうだが、こちらはあまりポジティブに捉えるべきではないように思う。それらの対処法にも興味はあるが、「0→1」フェーズでは発生することは考えにくいため、この記事ではスコープ外とした。「0→1」フェーズにおける技術的負債「0→1」フェーズでは必然的に「技術的負債」が大量に生まれやすい構造になっている。まず「0→1」フェーズについて整理しておく。現在所属している Ubie株式会社では、事業フェーズを次のように定義している。（ちなみにUbieは、担当するフェーズごとに「Ubie Discovery」と「Ubie Customer Science」という2つの組織に分かれている。私は 「0→10」を担う「Ubie Discovery」に所属している。）「0→1」フェーズでは、PSF（Problem/Solution Fit）を目指す。PSFとは、ユーザーが抱える課題（= Problem）を発見し、それらを解決する「MVP（Minimum Viable Product）」（= Solution）が特定できている状態である。言い換えると、「仮説はある。だが実際はどうなのか、何もわからん」状態から、仮説検証を何度も繰り返し、そこから学びを得てユーザーの課題やプロダクトのあるべき姿を探っていくフェーズである。「新たな学びを得ること」こそが「0→1」でやるべきことなので、多くの「学びから生まれる技術的負債」が発生するのは当然であり、健全に検証サイクルが回っている証とも言える。また、いかにすばやく仮説検証が繰り返せるかが重要になってくるため、「計画的な技術的負債」も効果的に利用していきたいところである。とはいえ、技術的負債は必ず「返済」する必要がある。「学びを得ることは正義」とはいえ、なんでもかんでも負債として抱えると、のちのち返済に苦しむ未来は容易に想像できる。また、積み上がった技術的負債によって、仮説検証のスピードが落ちてしまっては本末転倒である。したがって、生み出される負債の量をうまくコントロールする必要がある。どのように技術的負債を取り扱うか「学びから生まれる技術的負債」の場合「学び、学び」と書いているが、プロダクト開発をしていると様々な種類の学びが得られる。新たに獲得したドメイン知識ユーザー調査などから発見した解決すべき課題その課題を解決するための新たなソリューションアーキテクチャに関するベストプラクティスライブラリやフレームワークのAPIや機能に関する知見コードレビュー、勉強会、SNSなど様々な経路を通じて知った「もっといいコードの書き方」シャワーを浴びながらひらめいた実装アイディアもっとたくさんあると思うが、次の2つに大きく分けられそうである。仮説検証による学びエンジニアリングに関する学び前者の「仮説検証による学び」は多ければ多いほどよい、というのは自明だろう。後者の「エンジニアリングに関する学び」は、エンジニアとしての成長を意味するのでよいことではあるのだが、「0→1」フェーズにおいては、そこから生まれる技術的負債が、仮説検証を妨げる要因になりがちではないかと感じる。ソースコードの品質が低すぎると、バグフィックスに追われてそもそも検証が進まないというのは想像しやすい。例えば、安易な例だが「使ったことはないけど、このフレームワークは流行ってるし今回の要件に向いてそうなので採用！」というような意思決定は、仮説検証による学びよりも、新しい技術を使うことによる学び（とそこから生まれる技術的負債）に多くの気を取られてしまうためリスクが高い。すでに利用実績があって、知見が溜まっているものを選択したほうがよいだろう。（では「手に馴染んだ枯れたフレームワーク」を採用すればよいかというと、「0→1」に成功してその先のフェーズに進んだときに「時代遅れのフレームワーク」になっていて、世の中に広まっている新たなベストプラクティスを採用しづらい状況になっている、というようなこともありうるので難しい。）また、「0→1」フェーズでは細かな単位で「作っては捨て、作っては捨て」を繰り返す。未熟なアーキテクチャや全体設計になっていると、一回一回の変更に時間がかかってしまう。経験を積むことでよりよい設計が見えてくることも当然あるが、最初から仮説検証のスピードを維持するためには「ある程度の安定性はありつつ変更も加えやすいようなアーキテクチャ」といったものを初期の段階からしっかりと組めるに越したことはない。（が、初期構築に時間をかけすぎると、そもそも仮説検証をスタートできないので、こだわりすぎるのもよくない。難しい。）「技術力が高くなければ『0→1』の開発はするべきではない」と言うつもりは毛頭ないし（そんなことを言えば自分にブーメランが返ってくるだけだ）、たとえ何かを妨げる結果になったとしても、何かしらの学びを得ることはそれ自体尊いことだと思う。しかし、特に「0→1」フェーズに限って言えば「エンジニアリングに関する学び（とそこから生まれる技術的負債）」は、極力小さくなるようにコントロールするべきではないだろうか。（別の言い方をすれば、エンジニアリングに関する不確実性は、できるだけ小さくしておくほうがよい。）「計画的な技術的負債」の場合「計画的な技術的負債」というのは、例えば「将来的には自前のバックエンドが必要になりそうだけど、今はひとまず SaaS で検証を進める」とか、「このコンポーネントは共通化できそうな気がするけど、そもそも検証したら要らなくなるかもしれないし、いったんコピペで対応する」といったものをイメージしている。「計画的な技術的負債」に関しては、仮説検証を加速させるブースターのような役割があるので、積極的に利用したほうがよさそうだ。ただし負債としてたまり続けると、腐臭を漂わせることになるので、返済することは絶対に忘れるべきではない。「計画的な技術的負債」の場合は「学びから生まれる技術的負債」とは違い、それを積んだ背景やコンテキストが明確で、返済すべき条件やタイミングがあらかじめ想定できているはずだ。したがって、ADRやTODOファイル、コメントアウトなど（フォーマットは何でもよいが）記録を残し、いつでも確認できるようにしておくことが大切だろう。また、「返済のしやすさ」もある程度考慮したうえで負債を積むこともできるはずである。例えば「自前のバックエンドにデータを移しやすいような SaaS を選定する」とか、「フロントエンドのインフラストラクチャ層でデータアクセスを抽象化しておいてバックエンドのリプレイスの影響を受けにくいようにしておく」とか、「共通化しそうなコンポーネントは名前のプレフィックスを合わせる」とか、やれることはたくさんある。さいごにあくまで個人的な経験から得た「学び」をまとめたものである点はご了承ください。みなさんの意見も聞かせてもらえると嬉しいです。","link":"https://jmblog.jp/posts/2021-09-15/how-to-deal-with-technical-debt-in-start-up-companies","isoDate":"2021-09-15T00:00:00.000Z","dateMiliSeconds":1631664000000,"authorName":"jimbo","authorId":"jimbo"},{"title":"private な npm パッケージを Dockerfile でインストールして GitHub Actions でビルドする","contentSnippet":"はじめにこんにちは。医療系スタートアップ Ubie株式会社の「Ubie Discovery」というチームで働くWebフロントエンドが得意なソフトウェアエンジニアです。社内限定のプライベートな npm パッケージを開発し、npm registry や GitHub Packages に登録して、さまざまなプロジェクトで npm install して利用することがあると思います。（Ubie にも GitHub Packages で管理するプライベートな npm パッケージが存在しています。）パブリックなパッケージと違い、プライベートなパッケージを npm install するた...","link":"https://zenn.dev/jimbo/articles/403a5d98624c1b","isoDate":"2021-06-10T14:47:24.000Z","dateMiliSeconds":1623336444000,"authorName":"jimbo","authorId":"jimbo"},{"title":"2020年振り返り","contentSnippet":"2020 年を振り返ってみる。ポルトガル旅行の中止長女も中学生となり、家族で海外旅行ができるのも今年がラストチャンスになりそうだと思い、年初からポルトガル旅行の計画を立てていた。フライトを予約し、宿泊先を Airbnb で確保し、あとは行くだけと楽しみにしていたが、2 月半ばから新型コロナウイルスの影響で雲行きが怪しくなってくる。3 月頭にはヨーロッパでも感染が広がり、フライトもキャンセルとなってしまった。次はいつ行けるのか...小中学校の休校3 月 2 日から臨時休校となり、6 月になってようやく再開となった。長女が通っている塾ではしばらくしてオンライン授業がはじまったが、公立の小中学校では 3 ヶ月間自宅学習のみ。対応力の差を如実に感じた。子どもたちにとっては、早起きしなくていいし、わからないところは親に聞いたり YouTube の映像授業で調べれば済むしで、そんなに困ることもなかったっぽいが、親にとっては非常事態でいろいろ気を揉むことが多かった。体づくり去年の振り返りで「2020 年は体を鍛えたい。」と書いたが、今年は家にいる時間が長かったので、継続的に体づくりができた。2 月には家族全員で「1 ヶ月プランクチャレンジ」をやりきったし、その後も YouTube でお気に入りのパーソナルトレーナーのチャンネルを見ながら定期的に体を動かせた。その結果、ずっと悩まされていたぎっくり腰も今年は 1 回もかからずに過ごすことができた。仕事ヘルステック（医療 x テクノロジー）のスタートアップである Ubie にとって、新型コロナの影響は非常に大きかった。現在開発を担当している生活者（toC）向けサービス「AI 受診相談ユビー」は、感染拡大をうけて、当初の計画を大幅に前倒して 4 月 28 日に緊急リリースした。その後も、いくつかのニュース番組で取り上げられて喜んでいたらアクセスが集中して冷や汗をかいたり、リリースしたものの思うように数字が伸びず苦しんだり、4Q は逆に施策がはまって数字がどんどん伸びたりと、プロダクトづくりの面白さを実感する 1 年だった。会社自体も、社員数が 3 倍になり、さまざまな組織づくりも進められ、アウトプットの多い 1 年となった。2020 年、20 億円の資金調達からグローバル進出まで。Ubie の 1 年間ふりかえり。｜ Ubie (ユビー)｜ note来年にむけておかげさまで仕事は順調だし、まだまだやることがたくさんある。この勢いのまま、来年も突き進みたい。日常生活では、人に会う機会は激減してしまったし、常に新型コロナにおびえながら生活するのはなかなかしんどい。正月の帰省も諦めた。来年の今ごろはどんなふうになっているのか想像できないが、1 日でも早く安心してみんなで集まって騒げる日が戻ってくることを願ってる。","link":"https://jmblog.jp/posts/2020-12-30/looking-back-2020","isoDate":"2020-12-30T00:00:00.000Z","dateMiliSeconds":1609286400000,"authorName":"jimbo","authorId":"jimbo"},{"title":"地方で暮らしながら都内のスタートアップでのびのびと働くソフトウェアエンジニアの話","contentSnippet":"これは何Ubie Advent Calendar 2020 6日目の記事です。続きをみる","link":"https://note.com/yjimbo/n/nc4fba7999c90","isoDate":"2020-12-06T08:34:33.000Z","dateMiliSeconds":1607243673000,"authorName":"jimbo","authorId":"jimbo"},{"title":"2019年振り返り","contentSnippet":"2019 年を振り返ってみる。仕事約 6 年間勤めた Kaizen Platform を退職して、Ubie 株式会社に転職した。（人生 3 度目の転職）1 月末が Kaizen Platform の最終出社で、有給休暇を消化しながら、2 月から Ubie で働き出した。2 月の 1 ヶ月間は、東京に滞在してオンボーディング。普段会えない友人たちともひさびさに会うこともできた。最初に担当したのは、AI 問診 Ubie のタブレット問診機能のフロントエンド開発。当初は Rails の上に React の SPA が乗っかっていたので、脱 Webpacker をし、 Rails への依存をなくした。また、JavaScript と TypeScript が混在している状態だったので、こちらも TypeScript へ完全移行した。コードベースの整備はうまく進められたが、プロダクトの機能開発は、チームとしてあまりうまく進めることができずにいた。しかし、スクラム開発を導入し、チーム構成とプロジェクトの進め方を見直したことで、状況は劇的に改善された。（詳しくは、こちらの資料を参照。）ちゃんとしたスクラム開発ははじめてだったが、こうも変わるものかとちょっと感動した。6 月から 9 月までは、品質をあげつつ、高齢者向けの UI 改善施策を多く行った。その内容は FRONTEND CONFERENCE 2019 で発表することができた。9 月からは Vue.js（Nuxt.js）を使った別プロダクトを担当している。「AI 問診 Ubie」が拡大フェーズに入ってきた一方、こちらのプロダクトはまだまだ検証を進めているフェーズなので、より緊張感を持ちながらも毎日楽しみながら過ごしている。Vue.js はほぼ初めて触るが、正直、まだ手に馴染んでこない。Composition API も試験的に導入してみたので、もう少し様子を見てみたい。また、Firebase もがっつり触ることができてよかった。会社自体は、自分が入社したときには 20 名くらいだったが、12 月には 2 倍近くに増えた。東京オフィスに行くたびに知らない顔が増えていて、勢いを感じる。人が増え、プロダクトが拡大していくなか、当然問題もいろいろ出てくるが、それらをすばやく解決しながらさらに前に進んでいくという体験は、スタートアップならではの面白さだと思う。2020 年も大いに楽しみたい。プライベート3 月に福岡へ旅行に行った。夏休みには青森へ旅行に行った。キャンプは 3 回行った。ガンバ大阪の試合はホーム最終戦だけスタジアムで観戦した。頻繁に腰を痛めるようになってきた。2020 年は体を鍛えたい。","link":"https://jmblog.jp/posts/2019-12-30/looking-back-2019","isoDate":"2019-12-30T00:00:00.000Z","dateMiliSeconds":1577664000000,"authorName":"jimbo","authorId":"jimbo"},{"title":"FRONTEND CONFERENCE 2019 に登壇しました","contentSnippet":"11/3 にグランフロント大阪で開催された FRONTEND CONFERENCE 2019 で「高齢者でも使えるプロダクト UI の挑戦」というタイトルで発表しました。高齢者でも使えるプロダクト UI の挑戦 / Designing User Interfaces for the Elderly - Speaker Deck高齢者にも使ってもらえるプロダクトにするために、これまで地道に改善を続けてきたことを事例として共有するという内容でしたが、ありがたいことに、発表後たくさんの質問をいただきました。その場でうまく回答できなかった部分もあったので、あらためてこの場で回答をさせてもらいたいと思います。「色覚障害の見え方をチェックするためのおすすめのツールは？」スライドの中でも紹介した NoCoffee という Chrome 機能拡張以外に、Mac アプリでは Sim Daltonism が使いやすくおすすめです。「50px ってどうやって決めた？」このスライドにある「50px」という数字はどのように決めたのかという質問でした。その場では「えいやで決めました」と回答してしまったのですが、過去のチケットを探ってみたら、ちゃんと経緯が書いてありました。Apple の Human Interface Guidelines では、コントロール要素のタップ領域を 44pt 以上の大きさにするよう定められています（参考）。この数字をベースに、指の揺れ幅を加味した結果「50px」にしたとのことでした。（ちなみに、この数字をあまり大きくしてしまうと、今度はスクロールがうまく効かなくなってしまうので注意が必要です。）「高齢者のユーザービリティをあげると、他の年代の人にとって使いにくものにはならないか？」高齢者にとって使いやすいものが必ずしも他の年代の人にとって使いやすいものにはならないかもしれないが、どのように考慮しているか、という質問でした。例えば、パソコンやスマホを日常的に利用している人にとっては、「あいうえお配列のキーボード」で入力するよりも、普通にテキスト入力をするほうが使いやすいというのは間違いないと思います。ただ、そういったユーザーでも「あいうえお配列キーボード」が使えないということはないはずです。今のフェーズでは、あらゆる年代の方が自分の症状をタブレットで正確に伝えきるというタスクを遂行してもらうことが最も重要であり、若年層は多少回りくどい操作であっても使いこなせてしまうので、現時点では「使いやすさ」を追求するよりは、高齢者でも「使える」レベルにプロダクトを引き上げることに注力しています。このレベルをクリアできるようになったら、「使いやすさ」や「使って心地よい体験」というさらに上のレベルを目指していければと思います。「左右の入れ替えで左利きのひとの考慮は？」レイアウトを左右に入れ替えたというこのスライドについて、左利きの人だと問題が解決しないのではというご指摘でした。まさに仰るとおりで、利き手に関係なく使えるようなレイアウトにするべきですし、そもそもこの画面は、他と比べて行うべきタスクが多く、ユーザーが最も難しさを感じる箇所でもあるので、まだまだこの画面には課題が多くあるとチームでも認識しています。引き続き改善をしていきたいと思います。「チームがうまく機能しているように感じるのだが、どういう工夫をしているのか？」その場では簡単に「スクラムがうまく機能しているおかげ」と回答しましたが、他の社員が別のイベントで発表した資料に、チームづくりの話が詳しく出てきますので、ぜひご覧ください。（前半は、今回の私の発表と重複した内容になっています。）高齢者 UI への取り組みと自発的改善チームの作り方 / Elderly UI and Scrum Team - Speaker Deck最後に自分の発表を聞きに来てくださった方々、ありがとうございました。何か一つでも普段の業務に生かせるヒントとなれば幸いです。FRONTEND CONFERENCE には毎年参加しているのですが、エンジニアリングとデザインの話がバランス良く聞けて、いつも刺激をもらえます。今年も多くの素晴らしい発表がありました。運営スタッフの皆さん、ありがとうございました。来年も参加できることを楽しみにしています！","link":"https://jmblog.jp/posts/2019-11-03/frontend-conrefence-2019","isoDate":"2019-11-03T00:00:00.000Z","dateMiliSeconds":1572739200000,"authorName":"jimbo","authorId":"jimbo"},{"title":"lit-html と ShadyCSS","contentSnippet":"lit-html が v0.9.0 で ShadyCSS をサポートするようになったということなので、いろいろと調べてみた。TL;DR現時点では、Shadow DOM のスタイルカプセル化に対応するには ShadyCSS を使う必要がある。lit-html 経由で ShadyCSS を使うと便利。Shadow DOM の Polyfill2018 年 2 月現在、各ブラウザの Shadow DOM v1 のサポート状況は次のようになっている。Chrome と Opera は済み 🙆‍Safari と iOS Safari は一部バグあり 🤔Firefox と Edge はまだ 🙅‍（参考：https://caniuse.com/#feat=shadowdomv1 ）したがって、幅広いブラウザに対応するには、 現段階では Web Components の Polyfill (webcomponents.js) の利用が前提となる。Polyfill には webcomponents-lite.js や webcomponents-sd-ce.js などターゲットブラウザとサポートしたい仕様に応じていくつかのファイルが公開されているが、これらのうち「Shady DOM/CSS をサポート」となっているものには、実は「Shadow DOM のスタイルがカプセル化されない」という問題がある。（Shady CSS をサポートって書いてあるのに！！）Shadow DOM のスタイルカプセル化とは例えば \u003cmy-avatar\u003e という次のような Custom Element があったとする。import { html, render } from 'lit-html';class MyAvatar extends HTMLElement {  //...  _render() {    const template = html`      \u003cstyle\u003e        img {          border-radius: 50%;          border: 1px solid #ccc;        }      \u003c/style\u003e      \u003cimg src=\"${this.src}\" width=\"160\" height=\"160\" /\u003e    `;    render(template, this.attachShadow({ mode: 'open' }));  }}element.attachShadow() で Shadow DOM を生成しているので、ここで定義した \u003cimg\u003e のスタイルは Shadow DOM 内にのみ適用される = カプセル化されているというのが期待する挙動だ。それを確認するために、次のような HTML を用意してみる。\u003cimg src=\"https://randomuser.me/api/portraits/lego/7.jpg\" width=\"160\" /\u003e\u003cmy-avatar src=\"https://randomuser.me/api/portraits/lego/7.jpg\"\u003e\u003c/my-avatar\u003eChrome 64 と Firefox 58 でそれぞれ確認した結果がこれ。Chrome 64 での結果（左：\u003cimg\u003e　右：\u003cmy-avatar\u003e）  Firefox 58 での結果（左：\u003cimg\u003e　右：\u003cmy-avatar\u003e）Chrome では、期待どおり \u003cmy-avatar\u003e にだけスタイルが適用されているのがわかる。しかし、Firefox の場合、\u003cmy-avatar\u003e で定義したスタイルが通常の \u003cimg\u003e にも適用されてしまっている。Shadow DOM 内のスタイルが外に漏れ出しているのだ。逆に Shadow DOM の外で定義されたスタイルも Shadow DOM 内を汚染することになる。ShadyCSS とはこの問題を解決するためのライブラリ（Polyfill）が ShadyCSS だ。「スタイルのカプセル化」をサポートしたい場合、webcomponents.js の Polyfill に加えて、ShadyCSS も使う必要がある。https://github.com/webcomponents/shadycssShadyCSS の処理を通すと、Firefox などのブラウザでは、上記の \u003cmy-avatar\u003e のコードが次のように擬似的な Scoped Style に変換される。\u003chead\u003e  \u003cstyle scope=\"my-avatar\"\u003e    img.kz-avatar {      border-radius: 50%;      border: 1px solid #ccc;    }  \u003c/style\u003e\u003c/head\u003e\u003cbody\u003e  \u003ckz-avatar src=\"https://randomuser.me/api/portraits/lego/7.jpg\"\u003e    \u003cimg class=\"style-scope kz-avatar\" src=\"https://randomuser.me/api/portraits/lego/7.jpg\" height=\"160\" width=\"160\" /\u003e  \u003c/kz-avatar\u003e\u003c/body\u003eただ、Usage にあるように素で使おうとすると結構めんどくさいコードを書く必要がある。でも、lit-html 経由で ShadyCSS を利用するととても簡単に書くことができる。lit-html で ShadyCSS を使うというわけで、ようやく本題。lit-html で ShadyCSS を利用するには、 lit-html の render() の代わりに lit-html/lib/shady-render.js の render() を使う。import { html, render } from 'lit-html/lib/shady-render.js';class MyAvatar extends HTMLElement {  static get is() {    return 'my-avatar';  }  //...  _render() {    const template = html`      \u003cstyle\u003e        img {          border-radius: 50%;          border: 1px solid #ccc;        }      \u003c/style\u003e      \u003cimg src=\"${this.src}\" width=\"160\" height=\"160\" /\u003e    `;    render(template, this.attachShadow({ mode: 'open' }), MyAvatar.is);  }}window.customElements.define(MyAvatar.is, MyAvatar);lit-html の render() との違いは、第三パラメータにスコープ名を渡す必要がある点。ここで渡した値が \u003cstyle\u003e の scope 属性にセットされる。これは、タグ名と一致している必要がある。いずれにせよ、最小限のコードで ShadyCSS が使えるのはうれしい。ただし、制約もあって、例えば、const template = html`  \u003cstyle\u003e    img {      width: ${this.size}px;    }  \u003c/style\u003e  \u003cimg src=\"${this.src}\" width=\"160\" height=\"160\" /\u003e`;というように、 \u003cstyle\u003e の中で変数を展開しようとすると、\u003cstyle scope=\"my-avatar\"\u003e  img.kz-avatar {    width: \u003c!-- {      lit-8364277839110217    }  }\u003c/style\u003eというように変換されてしまってうまくいかない。こういうユースケースに対応したいならば、おとなしく Polymer などのライブラリを利用するほうがよいだろう。まとめというわけで、Firefox と Edge が Shadow DOM をサポートするまでは、lit-html + ShadyCSS の組み合わせが有力な選択肢になりそう。","link":"https://jmblog.jp/posts/2018-02-15/lit-html-with-shadycss","isoDate":"2018-02-15T00:00:00.000Z","dateMiliSeconds":1518652800000,"authorName":"jimbo","authorId":"jimbo"},{"title":"Nuxt.js で Markdown ベースのブログを構築する（サイトパフォーマンス編）","contentSnippet":"この記事は「Nuxt.js で Markdown ベースのブログを構築する」シリーズの一部です。Nuxt.js で Markdown ベースのブログを構築する（Markdown 編）Nuxt.js で Markdown ベースのブログを構築する（Nuxt.js 編）Nuxt.js で Markdown ベースのブログを構築する（サイトパフォーマンス編） ← ここ今回はサイトのパフォーマンスをあげるためにやったことをまとめる。サイト構築初期の状態サイトを構築したばかりの頃の Lighthouse のスコアは次のような感じだった。サイト構築初期の Lighthouse のスコア「Progressive Web App」のスコアが低いのは、Service Worker を使っていなかったのが要因で、「Accessibility」と「SEO」のスコアが低いのは、単に自分が書いたマークアップの品質が低かったため。注目すべきは「Performance」と「Best Practices」の 2 つだ。特別なことはそれほどしていないにも関わらず、はじめから非常に高いスコアが出ていた。Nuxt.js と Netlify を使ったおかげと言える。Nuxt.js の恩恵Nuxt.js は、特に設定しなくても、コード分割（Code splitting）CSS の HTML へのインライン展開Resource Hints によるリソースの事前取得の設定といった、Web フロントエンドの最新のベストプラクティスを自動でやってくれる。この点は、Web フロントエンド界隈から生まれたフレームワークの強みで、以前からある Jekyll や Hugo といった静的サイトジェネレーターとの決定的な差だと思う。Netlify の恩恵Netlify は、HTTP2SSLといった、サイトパフォーマンスには欠かせない機能を無料で提供してくれるのがありがたい。しかも設定がとても簡単で、SSL なんかはボタンを 1 クリックするだけで作業が完了して感動した。追加でやったことというわけで、あとは細かい点をチューニングするだけだった。主にやったことはこんな感じ。バンドルファイルの最適化nuxt build --analyze（または build プロパティの analyze オプション）を使って、バンドルファイルの中身を分析Qiita API のレスポンスをまるごと含まれた巨大な JSON ファイルがバンドルされていたのを発見。最小限のフィールドのみを保存するようにした。PWA 化（Service Worker の導入）Nuxt.js の PWA モジュール を利用した。アクセシビリティ対応SVG のアクセシビリティ対応テキスト色のコントラストを調整した。Chrome 64 から使える DevTools の新機能が便利だった。アクセシビリティについては、まだまだ勉強不足。。。HTTP/2 Server PushHTTP/2 Server Push on Netlify | Netlify を参照。自前の Nuxt.js モジュールを書いてやってみた。けど、ほとんどパフォーマンス上の変化はなかった。結果ほぼ 100 点になった 🎉 （Performance は計測するごとに多少のばらつきがあるが 90 点以上は出てる。）チューニング後の Lighthouse のスコアまとめシンプルなサイトだということもあるが、Nuxt.js と Netlify のおかげで、わりと簡単にパフォーマンスの高いサイトを構築することができた。とはいえ、時間の経過とともに、問題も出てくるだろうから、定期的にチェックしていきたい。ちなみに、サイトパフォーマンスの改善方法については、超速! Web ページ速度改善ガイドがとても参考になる。基本的な知識から最新の Web 技術まで体系的に学べる良書でおすすめです。","link":"https://jmblog.jp/posts/2018-01-24/build-a-blog-with-nuxtjs-and-markdown-3","isoDate":"2018-01-24T00:00:00.000Z","dateMiliSeconds":1516752000000,"authorName":"jimbo","authorId":"jimbo"},{"title":"Nuxt.js で Markdown ベースのブログを構築する（Nuxt.js 編）","contentSnippet":"この記事は「Nuxt.js で Markdown ベースのブログを構築する」シリーズの一部です。Nuxt.js で Markdown ベースのブログを構築する（Markdown 編）Nuxt.js で Markdown ベースのブログを構築する（Nuxt.js 編） ← ここNuxt.js で Markdown ベースのブログを構築する（サイトパフォーマンス編）今回は Nuxt.js 側の実装について紹介する。記事ページの実装本ブログでは、記事ページの URL を /posts/YYYY-MM-DD/xxx-yyy-zzz/ というルールにしている。このような動的なルーティングを Nuxt.js で実装するには、pages└── posts/    └── _date/       └── _slug/            └── index.vueというディレクトリ構造にするだけで済む。_ で始まるディレクトリ名はパラメータとして扱われる。つまり、 _date と _slug がそれぞれ YYYY-MM-DD と xxx-yyy-zzz に該当する。pages/posts/_date/_slug/index.vue の中身を見てみよう。\u003ctemplate\u003e  \u003cdiv\u003e    \u003ch1\u003e{{ title }}\u003c/h1\u003e    \u003cdiv class=\"post-meta\"\u003e\u003ctime\u003e{{ params.date }}\u003c/time\u003e\u003c/div\u003e    \u003cdiv v-html=\"bodyHtml\"\u003e\u003c/div\u003e  \u003c/div\u003e\u003c/template\u003e\u003cscript\u003e  import { sourceFileArray } from '../../../../content/posts/json/summary.json';  export default {    validate({ params }) {      return sourceFileArray.includes(`content/posts/${params.date}-${params.slug}.md`);    },    asyncData({ params }) {      return Object.assign({}, require(`~/content/posts/json/${params.date}-${params.slug}.json`), { params });    },    head() {      const title = `${this.title} - jmblog.jp`;      const url = `https://jmblog.jp/posts/${this.params.date}/${this.params.slug}/`;      return {        title: title,        meta: [          { hid: 'og:url', property: 'og:url', content: url },          { hid: 'og:title', property: 'og:title', content: title },        ],        link: [{ rel: 'canonical', href: url }],      };    },  };\u003c/script\u003e\u003cstyle\u003e  @import 'assets/tomorrow-night-bright.css';\u003c/style\u003e\u003cstyle lang=\"scss\" scoped\u003e  .post-meta {    font-size: 0.8em;    color: #888;    margin-top: -1rem;    margin-bottom: 2.4rem;    text-align: right;  }\u003c/style\u003eVue.js の単一ファイルコンポーネントになっていて \u003ctemplate\u003e、\u003cscript\u003e、\u003cstyle\u003e の 3 つで構成されている。\u003ctemplate\u003e\u003ctemplate\u003e の中はすごくシンプル。後述する \u003cscript\u003e の asyncData メソッドで用意したデータ（タイトルと投稿日と Markdown から変換した HTML）を流し込んでいるだけ。\u003cscript\u003e\u003cscript\u003e がこのファイルのメインとなる。まず validate メソッドで、アクセスされたページが実際に存在しているかをチェックしている。ここでは、前回の記事で紹介した summary.json の sourceFileArrayフィールドに、対象の Markdown ファイルのパスが含まれているかどうかで、ページの存在を判定している。ちなみに params という引数が渡ってきているが、ここには先ほど説明した pages/ 以下の _ で始まるディレクトリ名とその値がセットされている。つまり、/pages/2018-01-01/new-post/ という URL にアクセスした場合、params の中身はparams = {  date: '2018-01-01',  slug: 'new-post',};のようになる。asyncData メソッドでは、該当する記事ページの JSON ファイル（Markdown ファイルから変換したもの）を読み込んでいる。JSON オブジェクトだし、Markdown で書いた本文も HTML に変換済みなので、そのまま return して \u003ctemplate\u003e に渡すだけで済む。最後に head メソッドでは、\u003chead\u003e の中身（title とか description）をセットしている。\u003cstyle\u003e\u003cstyle\u003e で import しているのは highlight.js 用のテーマ CSS。ちなみに、以前私が作って、本家のリポジトリに取り込まれたファイルだったりする。静的ファイルの書き出しNuxt.js では nuxt generate コマンドで HTML ファイルが生成することができるが、動的なルーティングは無視されるため、そのままだと各記事ページは生成されない。これらの HTML ファイルも生成するには nuxt.config.js の generate オプションを使う必要がある。ここでも summary.json が活躍する。const { sourceFileArray } = require('../content/posts/json/summary.json');const sourceFileNameToUrl = require('./sourceFileNameToUrl');const generateDynamicRoutes = (callback) =\u003e {  const routes = sourceFileArray.map((sourceFileName) =\u003e {    return sourceFileNameToUrl(sourceFileName);  });  callback(null, routes);};module.exports = {  //...  generate: {    routes: generateDynamicRoutes,  },  //...};これで dist ディレクトリには posts/2018-01-01/new-blog/index.html といったファイルが生成されるようになる。sitemap.xml の生成sitemap.xml は @nuxtjs/sitemap を使えば簡単に生成できる。npm か yarn でインストールしたあと、nuxt.config.js に追加する。module.exports = {  //...  modules: ['@nuxtjs/sitemap'],  sitemap: {    path: '/sitemap.xml',    hostname: 'https://jmblog.jp',    generate: true,    exclude: ['/404'],    routes: generateDynamicRoutes,  },};動的ルーティングはやはりデフォルトでは無視されるため、routes オプションに、上で説明した generate と同じものを渡す必要がある。まとめというわけで、かなりお手軽に Nuxt.js で Markdown ベースのブログシステムを構築することができた。Nuxt.js は公式ドキュメントが充実していてほとんど迷うことがなかったし、Vue.js の単一ファイルコンポーネントもかなり書き心地がよかった。（もう少し複雑な Web アプリケーションになると違ってくるかと思うが。）Nuxt.js といえば、サーバーサイドレンダリングのためのフレームワークだという印象だったのだが、静的ファイルジェネレーターとしてもかなり使いみちが広いんじゃないかと今回感じた。機会があればまた使ってみたいと思う。サイトパフォーマンス編 に続く。","link":"https://jmblog.jp/posts/2018-01-18/build-a-blog-with-nuxtjs-and-markdown-2","isoDate":"2018-01-18T00:00:00.000Z","dateMiliSeconds":1516233600000,"authorName":"jimbo","authorId":"jimbo"},{"title":"Nuxt.js で Markdown ベースのブログを構築する（Markdown 編）","contentSnippet":"この記事は「Nuxt.js で Markdown ベースのブログを構築する」シリーズの一部です。Nuxt.js で Markdown ベースのブログを構築する（Markdown 編） ← ここNuxt.js で Markdown ベースのブログを構築する（Nuxt.js 編）Nuxt.js で Markdown ベースのブログを構築する（サイトパフォーマンス編）本ブログは、Markdown で記事を書き、Nuxt.js の静的ファイル生成機能を使って静的ファイルを書き出し、Netlify を使ってホスティングするというシステム構成になっている。具体的にどのようにしているか簡単に紹介する。processmd を使った Markdown ファイルの変換処理それぞれのブログ記事は YYYY-MM-DD-xxxxx.md という Markdown ファイルに書いている。ファイルの先頭に YAML front matter でメタ情報を記述するという、ブログ記事によく見られるフォーマットになっている。---title: 記事のタイトルcreated_at: 2018-01-01---## 見出し 2本文です。```javascriptconst f = () =\u003e {};```この Markdown ファイルは、Nuxt.js の中で変換処理を行うと複雑になるので、あらかじめ Nuxt.js（というか JS）で扱いやすいように、JSON ファイルに変換している。この処理に使っているのが processmd という CLI ツールで、これがとても便利だった。例えば、上にあげたような Markdown ファイルを processmd コマンドに渡すと{  \"title\": \"記事のタイトル\",  \"created_at\": \"2018-01-01T00:00:00.000Z\",  \"bodyContent\": \"## 見出し 2\\n\\n本文です。\\n\\n```javascript\\nconst f = () =\u003e {};\\n```\",  \"bodyHtml\": \"\u003ch2\u003e見出し 2\u003c/h2\u003e\\n\u003cp\u003e本文です。\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"hljs\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003econst\u003c/span\u003e f = \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {};\u003c/code\u003e\u003c/pre\u003e\",  \"dir\": \"content/posts\",  \"base\": \"2018-01-01-test.json\",  \"ext\": \".json\",  \"sourceBase\": \"2018-01-01-test.md\",  \"sourceExt\": \".md\"}といった JSON ファイルに変換してくれる。Front matter で書いたメタ情報はそれぞれフィールドとなり、bodyContent には元の Markdown が、 bodyHTML にはそれを markdown-it で HTML に変換した値が含まれる。よく見てもらえばわかるように、コードブロックは highlight.js が適用された状態の HTML で書き出されるので、あとは highlight.js 用のテーマ CSS を読み込むだけで、簡単にシンタックスハイライトが導入できる。また、--stdout というオプションをつけると、同時にサマリーファイルも書き出すことができる。$ processmd content/posts/**/*.md --stdout --outputDir content/posts/json \u003e summary.jsonsummary.json はこんな感じ。{  \"fileMap\": {    \"content/posts/json/2007-09-25-link-visited-hover-active.json\": {      \"title\": \":link、:visited、:hover、:active の記述順序とその覚え方\",      \"created_at\": \"2007-09-27T00:00:00.000Z\",      \"dir\": \"content/posts/json\",      \"base\": \"2007-09-25-link-visited-hover-active.json\",      \"ext\": \".json\",      \"sourceBase\": \"2007-09-25-link-visited-hover-active.md\",      \"sourceExt\": \".md\"    },    \"content/posts/json/2012-12-05-sass-if-function.json\": {      \"title\": \"Sass の if 関数\",      \"created_at\": \"2012-12-05T00:00:00.000Z\",      \"dir\": \"content/posts/json\",      \"base\": \"2012-12-05-sass-if-function.json\",      \"ext\": \".json\",      \"sourceBase\": \"2012-12-05-sass-if-function.md\",      \"sourceExt\": \".md\"    },    \"content/posts/json/2011-03-21-innerHTML-returns-serialized-html.json\": {      \"title\": \"innerHTML や jQuery.html() は HTMLをそのまま取得できるわけではない\",      \"created_at\": \"2011-03-21T00:00:00.000Z\",      \"dir\": \"content/posts/json\",      \"base\": \"2011-03-21-innerHTML-returns-serialized-html.json\",      \"ext\": \".json\",      \"sourceBase\": \"2011-03-21-innerHTML-returns-serialized-html.md\",      \"sourceExt\": \".md\"    }  },  \"sourceFileArray\": [    \"content/posts/2007-09-25-link-visited-hover-active.md\",    \"content/posts/2011-03-21-innerHTML-returns-serialized-html.md\",    \"content/posts/2012-12-05-sass-if-function.md\"  ]}Markdown ファイル名に日付（YYYY-MM-DD）を使っておくと sourceFileArray は日付順に並ぶので、記事一覧リストの実装にそのまま利用することができた。また、本ブログでは使っていないが --preview オプションを使うと、指定した文字分だけコンテンツの先頭をテキストで書き出してくれる。「記事一覧リストに本文の概要を載せたい」といった場合に便利だと思う。{  \"title\": \"記事のタイトル\",  \"created_at\": \"2018-01-01T00:00:00.000Z\",  \"bodyContent\": \"## 見出し 2\\n\\n新しいブログ記事です。\\n\\n```javascript\\nconst f = () =\u003e {};\\n```\",  \"bodyHtml\": \"\u003ch2\u003e見出し 2\u003c/h2\u003e\\n\u003cp\u003e新しいブログ記事です。\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"hljs\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003econst\u003c/span\u003e f = \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {};\u003c/code\u003e\u003c/pre\u003e\",  \"preview\": \"見出し 2\\n\\n新しいブログ記事です。\\n\\nconst f = () = {};\\n`\"}Nuxt.js 編 に続く。","link":"https://jmblog.jp/posts/2018-01-17/build-a-blog-with-nuxtjs-and-markdown-1","isoDate":"2018-01-17T00:00:00.000Z","dateMiliSeconds":1516147200000,"authorName":"jimbo","authorId":"jimbo"},{"title":"Nuxt.js を使ってブログを新しくした","contentSnippet":"2013 年から長らく放置していたブログを新しくした。以前のブログは WordPress を使っており、時折 WordPress 自体のアップデートはしていたものの、ほとんどの記事は古くて役に立たなくなっていたし、HTTPS 化もしていなかったし、スパムコメントも届いていたしで、インターネットを汚しているなぁという罪悪感がずっとあった。昨年末の休みに、ようやく重い腰を上げて作り直した。今回は WordPress をやめて Nuxt.js を採用した。詳しくは別途投稿しようと思う。古い記事については、アクセスがあって、内容もまだ賞味期限が切れていなさそうなものだけピックアップして移行した。また、最近は Qiita へもいくつか投稿していたため、API で取得して記事一覧に追加した。ホスティングは Netlify を使っている。いいサービスだと聞いていたが、実際に使ってみると UI もわかりやすく、デプロイも驚くほど簡単で感動した。HTTPS 化もあっけなく完了。長年の懸念をようやく払拭できて、すっきりした。2018 年もがんばっていこう。","link":"https://jmblog.jp/posts/2018-01-10/new-blog-with-nuxtjs","isoDate":"2018-01-10T00:00:00.000Z","dateMiliSeconds":1515542400000,"authorName":"jimbo","authorId":"jimbo"},{"title":"Vanilla JS や TypeScript で Custom Elements を書く際の注意点","contentSnippet":"Vanilla JS や TypeScript を使って Web Components の Custom Elements を書いてビルドした結果、ブラウザのコンソールにFailed to construct 'HTMLElement': Please use the 'new' operator, this DOM object constructor cannot be called as a function.というエラーが出ることがあります。原因Custom Elements が ES5 形式のコードになってしまっているのが原因です。仕様では、Custom Elements は ES6 の class 構文である必要があります。しかし、ビルド時に TypeScript や Babel を通すことで、意図せず ES5 形式のコードになってしまっていることがあります。この時、上記のエラーが出ます。チェックポイントTypeScript を使っている場合Compiler Options の --target が \"ES6\" になっているか確認します。tsconfig.json{  \"compilerOptions\": {    \"target\": \"ES6\"  },  \"include\": [\"src/**/*\"],  \"exclude\": [\"node_modules\"]}Babel を使っている場合Babel でトランスパイルをすると ES5 形式のコードになってしまいますが、babel-plugin-transform-custom-element-classes を併用することで上記のエラーを回避することができます。{  \"presets\": [\"env\"],  \"plugins\": [\"transform-custom-element-classes\"]}ES5 形式のコードをそのまま使いたい場合ES6 をサポートしていないブラウザも対象にする必要があるなど、ES5 形式のコードをそのまま使いたいというケースもあるかと思います。この場合、Custom Elements を宣言する前に custom-elements-es5-adapter.js という polyfill を読み込むと、 ES5 形式の Custom Element を正常に動かすことができます。","link":"https://qiita.com/jimbo/items/d17a121f815236c2f55b","isoDate":"2017-12-05T05:22:24.000Z","dateMiliSeconds":1512451344000,"authorName":"jimbo","authorId":"jimbo"},{"title":"WebdriverIO + ヘッドレス Chromeでローカルブラウザテスト","contentSnippet":"WebdriverIO からヘッドレス Chrome を起動してブラウザテストを実施する手順をまとめます。必要条件Chrome 59 以降がインストールされていることWebdriverIO およびブラウザテストについてSeleniumアレルギーのための処方箋 - Qiita にとても詳しくまとめられていますので、ぜひご一読ください。本投稿は、この記事にある、以下の構成図の「Local」という枠の中に関する話です。ここの「PhantomJS」のかわりに「ヘッドレスChrome」を利用する方法について紹介します。導入手順ChromeDriver のインストールWebdriverIO から ヘッドレスChrome を起動するには ChromeDriver が必要です。公式サイトから直接ダウンロードしてもよいのですが、パスを通したり、異なるプラットフォーム（OS）に対応したインストールプロセスを組んだりしなければならないのがちょっと面倒です。そのあたりをいい感じに面倒みてくれる selenium-standalone を利用するのがおすすめです。$ npm install selenium-standalone --save-devで selenium-standalone をインストールした後、$ selenium-standalone installを実行すると ChromeDriver がインストールされて実行可能になります。npm-scripts の postinstall コマンドに定義しておくと、他の人がプロジェクトを導入するときに親切ですね。package.json{  \"scripts\": {    \"postinstall\": \"selenium-standalone install\"  }}WebdriverIO のインストール次に WebdriverIO をインストールします。$ npm install webdriverio --save-devこれで wdio というコマンドが使えるようになります。$ wdio --helpWebdriverIO CLI runnerUsage: wdio [options] [configFile]Usage: wdio configUsage: wdio repl [browserName]config file defaults to wdio.conf.jsThe [options] object will override values from the config file.Options:  --help, -h            prints WebdriverIO help menu  --version, -v         prints WebdriverIO version  --host                Selenium server host address  --port                Selenium server port  --path                Selenium server path (default: /wd/hub)  --user, -u            username if using a cloud service as Selenium backend  --key, -k             corresponding access key to the user  --watch               watch specs for changes  --logLevel, -l        level of logging verbosity (default: silent)  --coloredLogs, -c     if true enables colors for log output (default: true)                                                                        [default: true]  --bail                stop test runner after specific amount of tests have failed (default: 0 - don't bail)  --screenshotPath, -s  saves a screenshot to a given path if a command fails  --baseUrl, -b         shorten url command calls by setting a base url  --waitforTimeout, -w  timeout for all waitForXXX commands (default: 1000ms)  --framework, -f       defines the framework (Mocha, Jasmine or Cucumber) to run the specs (default: mocha)  --reporters, -r       reporters to print out the results on stdout  --suite               overwrites the specs attribute and runs the defined suite  --spec                run only a certain spec file  --cucumberOpts.*      Cucumber options, see the full list options at https://github.com/webdriverio/wdio-cucumber-framework#cucumberopts-options  --jasmineOpts.*       Jasmine options, see the full list options at https://github.com/webdriverio/wdio-jasmine-framework#jasminenodeopts-options  --mochaOpts.*         Mocha options, see the full list options at http://mochajs.orgWebdriverIO の設定次に WebdriverIO の設定ファイルを作成します。wdio config を実行すると、設定ファイルを生成するためのウィザードが始まります。framework や reporter は好きなものを選んでください。「Do you want to add a service to your test setup?」という質問では 「selenium-standalone」 を選びます。完了すると wdio.conf.js が生成されるので、ファイルを開いて capabilities というセクションを探してください。wdio.conf.js    capabilities: [{        browserName: 'firefox'    }],デフォルトでは Firefox が起動するようになっています。次のように変更して、ヘッドレスChrome を使うようにします。wdio.conf.js    capabilities: [{        browserName: 'chrome',        'goog:chromeOptions': {          args: ['--headless', '--disable-gpu'],        },    }],--headless というフラグを指定すると、ヘッドレスモードで Chrome を実行することができます。また、--disable-gpu も現時点（2017年9月時点）ではヘッドレスモードで実行する際に必要です。（参考：ヘッドレス Chrome ことはじめ  |  Web  |  Google Developers）なお、これらのフラグを指定しなかった場合は、通常モードの Chrome が起動します。テストの実行試しに、適当なテストコードを用意して、wdio コマンドでテストを実行してみましょう。test/specs/test.jsvar assert = require('assert')describe('webdriver.io page', function() {  it('should be a pending test')  it('should have the right title - the fancy generator way', function() {    browser.url('http://webdriver.io/')    var title = browser.getTitle()    assert.equal(title, 'WebdriverIO - WebDriver bindings for Node.js')  })})$ wdio wdio.conf.jsmacOS の場合だと、Dock に Chrome のアイコンが出現して（ブラウザウインドウは表示されません）、テストが実行されれば成功です。","link":"https://qiita.com/jimbo/items/f40188dd9e8f8a62592d","isoDate":"2017-07-24T07:07:26.000Z","dateMiliSeconds":1500880046000,"authorName":"jimbo","authorId":"jimbo"},{"title":"webpack で moment.js の無駄なロケールファイルを除去する","contentSnippet":"moment.js を利用する際、const moment = require('moment');と書いて webpack でビルドすると、生成される bundle ファイルのサイズが非常に大きくなってしまいます。これは、moment.js が持つすべてのロケールファイルが bundle ファイルに含まれてしまうためです。ファイルサイズにシビアなフロントエンドではかなり大きな問題です。(上図は source-map-explorer を使って生成しました）解決策webpack の IgnorePlugin か ContextReplacementPlugin を使えば、この問題を回避することが出来ます。IgnorePlugin を使う場合「デフォルトの en 以外にロケールファイルは必要ない」という場合は、IgnorePlugin が使えます。webpack.config.jsconst webpack = require('webpack');module.exports = {  //...  plugins: [    // Ignore all locale files of moment.js    new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/),  ],};これですべてのロケールファイルが除去されます。また「特定のロケールだけ必要」という場合も、コードの中で require('moment/locale/xx') と書けば bundle ファイルに含めることができます。your-code.jsconst moment = require('moment');require('moment/locale/ja');moment.locale('ja');...この手法は create-react-app でも使われています。ContextReplacementPlugin を使う場合「en 以外にいくつかのロケールファイルを使いたい」というケースでは ContextReplacementPlugin が使えます。webpack.config.jsconst webpack = require('webpack');module.exports = {  //...  plugins: [    // load `moment/locale/ja.js` and `moment/locale/it.js`    new webpack.ContextReplacementPlugin(/moment[\\/\\\\]locale$/, /ja|it/),  ],};この場合、コードの中で require('moment/locale/xx') と書く必要はありません。your-code.jsconst moment = require('moment');moment.locale('ja');...どれぐらいサイズを減らせるか手元で検証してみたところ、以下のような結果になりました。File sizeGzippedDefault199 kB58.6 kBIgnorePlugin51 kB17.1 kBContextReplacementPlugin51 kB17.1 kBどちらの方法も、かなり効果があることがわかりました。まとめやや hacky ですが、現状ではこれが現実的な解決策です。どちらのプラグインでも結果はほとんど同じですが、個人的には webpack.config.js でロケールを指定する ContentReplacementPlugin よりも、コードの中で明示的に require('moment/locale/xx') と使うロケールを指定する IgnorePlugin のほうがベターではないかと思います。参考http://stackoverflow.com/questions/25384360/how-to-prevent-moment-js-from-loading-locales-with-webpack/37172595https://github.com/moment/moment/issues/2373","link":"https://qiita.com/jimbo/items/95da1c223ad25a33ed16","isoDate":"2016-11-25T09:12:03.000Z","dateMiliSeconds":1480065123000,"authorName":"jimbo","authorId":"jimbo"},{"title":"CI のビルド時に patch を適用する際の注意点","contentSnippet":"CI（継続的インテグレーション）のビルド処理の中で patch の適用を実行する際の注意点です。問題点CI（継続的インテグレーション）のビルド処理で cache に前回のファイルが残っていると、2回目のビルドで Reversed patch と判断されて元に戻ってしまうことがあります。例） node_modules/foo/bar/xxx に対して xxx.patch を適用したい場合# 1回目$ patch --batch -p0 -i xxx.patchpatching file node_modules/foo/bar/xxx# 2回目$ patch --batch -p0 -i xxx.patchpatching file node_modules/foo/bar/xxxReversed (or previously applied) patch detected!  Assuming -R. # 元に戻ってしまうReserved patch を無視するようにReversed patch を無視するには、patch コマンドの -N オプションを使います。$ patch --batch -N -p0 -i xxx.patchpatching file node_modules/foo/bar/xxxReversed (or previously applied) patch detected!  Skipping patch.1 out of 1 hunk ignored -- saving rejects to file node_modules/foo/bar/xxx.rejこれで元に戻ることを防ぐことはできるのですが、終了ステータスが「異常終了 (1)」となるため、CI 上でこれを実行するとビルドが失敗してしまいます。また、node_modules/foo/bar/xxx.rej ファイルができてしまうのも気になります。解決策一度 --dry-run で試してみて、成功したときだけ実行するようなスクリプトにすればこの問題を回避することができました。patch-xxx.sh#!/bin/bashPATCH_CMD=\"patch --batch --silent -p0 -N -i xxx.patch\"if ${PATCH_CMD} --dry-run; then  ${PATCH_CMD}fi","link":"https://qiita.com/jimbo/items/1643523195b03f53e860","isoDate":"2016-11-04T05:54:48.000Z","dateMiliSeconds":1478238888000,"authorName":"jimbo","authorId":"jimbo"},{"title":"Angular 2: Component のスタイル実装と CSS のカプセル化","contentSnippet":"先日行われた ng-kyoto Angular Meetup #3 にて、「CSS in JS と CSS Modules」という発表を行いました。Angular Meetup にも関わらず、React における Component のスタイリングに関する内容で、最後に「React 勢がこんなに頑張っているのに Angular ときたら」と煽るつもりだったのですが、直前の @armorik83 さんの発表で Angular 2 で同じような機能が実装されることを知り、慌ててオチを書き換えたのでした。というわけでこの記事では、 Angular 2 で Component のスタイルをどのように実装するか、CSS のカプセル化（ローカルスコープ化）がどのように行われるのかについて、見ていきたいと思います。前提この記事を執筆した時点での Angular 2 の最新バージョンは 2.0.0-alpha.51 です。デモ用アプリデモ用アプリを http://jmblog.github.io/angular2-styling-components-demo/ に用意しました。ソースコード一式は jmblog/angular2-styling-components-demo で入手可能です。興味のある方は Fork してご自身の環境でいろいろと触ってみてください。Component のスタイル実装Angular 2 で Component のスタイルを実装する方法には、3通りあります。ViewMetadata の styles プロパティを使うViewMetadata の styleUrls プロパティを使うテンプレートに \u003cstyle\u003e エレメントで埋め込むその1. ViewMetadata の styles プロパティを使うViewMetadata の styles プロパティを使って TypeScript 内に CSS を記述する方法です。app-title.tsimport {Component} from 'angular2/angular2';@Component({  selector: 'app-title',  template: `    \u003ch1 class=\"title\"\u003eDemo of Styling Angular2 Components\u003c/h1\u003e  `,  styles: [`    .title {      margin-bottom: 3rem;    }  `]})export class AppTitleComponent {}CSS のコード量が少なければまぁこれでもよいのですが、多くなってくると分離したくなってきますね。あと、エディタによっては HTML や CSS がうまくハイライトされないかもしれません。その2. ViewMetadata の styleUrls プロパティを使うCSS を外部ファイルにして、ViewMetadata の styleUrls プロパティで指定する方法です。profile-card.tsimport {Component, CORE_DIRECTIVES} from 'angular2/angular2';import {PeopleService} from '../../services/people';import {ProfileCardComponent} from '../profile-card/profile-card';@Component({  selector: 'profile-cards-list',  templateUrl: './components/profile-cards-list/profile-cards-list.html',  styleUrls: ['./components/profile-cards-list/profile-cards-list.css'],  providers: [PeopleService],  directives: [CORE_DIRECTIVES, ProfileCardComponent]})export class ProfileCardsListComponent {  constructor(public peopleService:PeopleService) {    peopleService.people      .subscribe(people =\u003e this.people = people);  }}この場合、AngularJS 1.x にもあった templateUrl と同じように、CSS ファイルが XHR により取得されます。Sass などのプリプロセッサや Autoprefixer を利用するのであれば、独立した CSS ファイルになっているほうが断然都合がいいので、この方法を選択することになるかと思います。なお、外部ファイル数が増えば増えるほど、HTTPリクエスト数も増えてしまい、パフォーマンスの問題が出てきますが、gulp-inline-ng2-template という gulp プラグインを利用すると、templateUrl や styleUrls で指定した外部ファイルを template と styles に展開してくれるので、この問題を回避することができます。その3. テンプレートに \u003cstyle\u003e エレメントで埋め込むテンプレート（HTML）の中に \u003cstyle\u003e エレメントを使って CSS を記述する方法です。profile-card.tsimport {Component, Input} from 'angular2/angular2';@Component({  selector: 'profile-card',  templateUrl: './components/profile-card/profile-card.html'})export class ProfileCardComponent {  @Input() person;}profile-card.html\u003cstyle\u003e  .profile-card {...}  .image {...}  .name {...}  .email {...}\u003c/style\u003e\u003cdiv class=\"profile-card\"\u003e  \u003cdiv class=\"image\"\u003e\u003cimg src=\"{{person.picture.medium}}\" width=\"80\"\u003e\u003c/div\u003e  \u003cdiv class=\"name\"\u003e{{person.name.first}} {{person.name.last}}\u003c/div\u003e  \u003cdiv class=\"email\"\u003e{{person.email}}\u003c/div\u003e\u003cdiv\u003eHTMLとCSSが同一ファイル内で隣接しているため、コードが書きやすいです。styles を使う場合と違って、通常のHTMLファイルにコードを書くことができますし、Sass や Autoprefixer を使わないのであれば、案外悪くないのではと思います。CSS のカプセル化（ローカルスコープ化）このように、スタイルの定義の方法にはいくつかありますが、どの方法を使っても、スタイルはそれぞれのコンポーネントに閉じたスコープにのみ適用されるようになっています。この CSS のカプセル化（ローカルスコープ化）がどのように実現されているのか、その仕組みを見てみましょう。カプセル化の仕組み例えば、デモ用アプリの app-title コンポーネントと profile-card コンポーネントには、それぞれ .title という同じ名前のクラスが存在しています。app-title.ts@Component({  selector: 'app-title',  template: `    \u003ch1 class=\"title\"\u003eDemo of Styling Angular2 Components\u003c/h1\u003e  `,  styles: [`    .title {      margin-bottom: 3rem;    }  `]})profile-card.html\u003cstyle\u003e....title {  text-transform: capitalize;  font-size: 1.2rem;  font-weight: 400;}...\u003c/style\u003e\u003cdiv class=\"profile-card\"\u003e  ...  \u003cdiv class=\"title\"\u003e{{person.name.first}} {{person.name.last}}\u003c/div\u003e  ...\u003c/div\u003e同じ名前を使っていますが、これらはお互い依存関係のない（つまりお互いのスタイルに影響を与え合わない）、独立したクラスを想定しています。ブラウザでアプリを実行すると、次のようにコンポーネントごとのスタイル定義が \u003chead\u003e の中に \u003cstyle\u003e で追加されていることが確認できるかと思います。index.html\u003c!DOCTYPE html\u003e\u003chtml\u003e\u003chead\u003e  ...  \u003cstyle\u003e    .title[_ngcontent-hpw-2] {      margin-bottom: 3rem;    }  \u003c/style\u003e  \u003cstyle\u003e    ...    .title[_ngcontent-hpw-5] {      text-transform: capitalize;      font-size: 1.2rem;      font-weight: 400;    }    ...  \u003c/style\u003e\u003c/head\u003e\u003cbody\u003e ...\u003c/body\u003e\u003c/html\u003eまた、コンポーネントの DOM 部分は次のようになっています。\u003capp-title _nghost-hpw-2=\"\"\u003e  \u003ch1 class=\"title\" _ngcontent-hpw-2=\"\"\u003eDemo of Styling Angular2 Components\u003c/h1\u003e\u003c/app-title\u003e\u003cprofile-card _ngcontent-hpw-3=\"\" _nghost-hpw-5=\"\"\u003e  \u003cdiv class=\"profile-card\" _ngcontent-hpw-5=\"\"\u003e    ...    \u003cdiv class=\"title\" _ngcontent-hpw-5=\"\"\u003eterrance obrien\u003c/div\u003e    ...  \u003c/div\u003e\u003c/profile-card\u003e注目すべきは _nghost-hpw-*, _ngcontent-hpw-* という部分です。これは Angular 2 が実行時に自動で挿入する属性で、hpw の部分はブラウザをリロードするたびに変化します。最後の数字の部分は 各要素のレベル（階層）を表しています。そして、これらを属性セレクタとしてスタイル定義に適用することで、仮に同じ名前のクラスであっても、適用される範囲がコンポーネント内に限られることになります。これにより、ローカルスコープ（カプセル化）を実現しているというわけです。.title[_ngcontent-hpw-2] {  margin-bottom: 3rem;}.title[_ngcontent-hpw-5] {  text-transform: capitalize;  font-size: 1.2rem;  font-weight: 400;}なお、この挙動は encapsulation というプロパティで変更することができます。このプロパティにセットできるのは次の3種類です。ViewEncapsulation.NoneViewEncapsulation.EmulatedViewEncapsulation.NativeViewEncapsulation.NoneViewEncapsulation.None を指定すると、カプセル化は一切行われず、すべてグローバルスコープに展開されます。import {Component, ViewEncapsulation} from 'angular2/angular2';@Component({  selector: 'app-title',  template: ...  styles: ...  encapsulation: ViewEncapsulation.None})export class AppTitleComponent {}index.html\u003c!DOCTYPE html\u003e\u003chtml\u003e\u003chead\u003e  \u003cstyle\u003e    .title {      margin-bottom: 3rem;    }  \u003c/style\u003e\u003c/head\u003e\u003cbody\u003e  \u003cmy-app\u003e    \u003capp-title\u003e      \u003ch1 class=\"title\"\u003eDemo of Styling Angular2 Components\u003c/h1\u003e    \u003c/app-title\u003e  \u003c/my-app\u003e\u003c/body\u003e\u003c/html\u003eなお、スタイルの定義がないコンポーネントに対しては、無駄な処理を防ぐため ViewEncapsulation.None がデフォルト値になるようです。ViewEncapsulation.Emulatedスタイルの定義がある場合のデフォルトはこれになります。上で見たように、各要素に独自の属性を割り当てることで、ローカルスコープ化を実現しています。ViewEncapsulation.Nativeネイティブ、つまり W3C で仕様策定中の Shadow DOM を使います。Shadow DOM に対応していないブラウザで実行するとエラーとなってしまうので、現時点では利用は限られるでしょう。まとめ以上、Angular 2 のスタイル実装の方法と CSS のカプセル化（ローカルスコープ化）について簡単にまとめてみました。Angular1.x の頃と比べるとずいぶんモダンになっている印象を受けました。ただ、コンポーネントの外部からスタイルを変更する方法が提供されているのかなど、わからない部分も多いので、引き続きウォッチしていきたいと思います。参考資料Styling Angular 2 componentsView Encapsulation in Angular 2","link":"https://qiita.com/jimbo/items/b347c19d935e796c2482","isoDate":"2015-12-10T15:01:20.000Z","dateMiliSeconds":1449759680000,"authorName":"jimbo","authorId":"jimbo"},{"title":"Qiita Notification Favicon 機能拡張を作りました","contentSnippet":"Qiita および Qiita:Team の通知をタブ上の Favicon で確認できる Chrome 機能拡張を作りました。リポジトリはこちら技術的な話background.js で qiita の notification API の通信を監視し、Request があれば Favicon を更新するようになっています。Event Page にしたかったけど、chrome.webRequest が Event Page に対応していなかった。Favicon の更新には、favico.js を使っています。よかったら使ってみてください。","link":"https://qiita.com/jimbo/items/4a7792f5772207e1e3eb","isoDate":"2014-06-04T13:04:03.000Z","dateMiliSeconds":1401887043000,"authorName":"jimbo","authorId":"jimbo"},{"title":"Taxman の紹介","contentSnippet":"こんにちは。Webエンジニアの神保と申します。この記事では、Open Knowldge Foundation のプロジェクトの一つである OpenSpending が開発している Taxman という API について紹介します。Taxman とはTaxman は、世界中の国や地域の税金が計算できることを目指して開発が進められている、シンプルな RESTful API です。（Taxman という名前は、ビートルズの曲名に由来しているようです。）まだプロトタイプのレベルですが、http://taxman.openspending.org でいくつかの地域のものがすでに稼働しています。対応しているエリアのリストは、何もパラメータをつけずにリクエストを投げると JSON形式で取得できます。$ curl -s \"http://taxman.openspending.org\" | jq '.'{  \"jurisdictions\": {    \"jp\": \"http://taxman.openspending.org/jp\",    \"gb\": \"http://taxman.openspending.org/gb\",    \"ba\": \"http://taxman.openspending.org/ba\",    \"mx\": \"http://taxman.openspending.org/mx\",    \"za\": \"http://taxman.openspending.org/za\",    \"bg\": \"http://taxman.openspending.org/bg\"  },  \"message\": \"Welcome to the TaxMan\"}この Taxman ですが、実際にいくつかのサイトで利用されています。私が知っているのは、イギリスの WHERE DOES MY MONEY GO?と、そのボスニア・ヘルツェゴヴィナ版である http://budzeti.ba の2つです。どちらも OpenSpending が開発したサイトですね。というか、WHERE DOES MY MONEY GO? でもともと実装されていた税金の計算部分を API として切り出して、汎用的に使えるものにしようというのが Taxman というわけです。日本版 Taxmanところで、上記の対応エリアリストを見てお気づきでしょうか。jp がありますね。そう、なんと日本版もあるのです！「なんと」と書きましたが、実はこの日本版は私が開発したものです。今年の7月に行われた Spending Data Party 2013 をきっかけに開発を進め、8月の終わり頃に本家に取り込まれる形となりました。現段階では、年収（年間給与収入）、配偶者の有無と年齢、扶養親族の人数と年齢から、所得税と住民税の2種類が計算できるようになっています。例）年収400万円、配偶者あり（37歳）、扶養親族2人（17歳と13歳）の場合（見やすいように一部編集してあります。）$ curl -s \"http://taxman.openspending.org/jp?income=4000000\u0026spouse=37\u0026dependents=17\u0026dependents=13\" | jq '.'{  \"calculation\": {    \"total\": 333500,    # 税額の総合計    \"inhabitant_tax\": { # 住民税      \"municipal\": {    # 都道府県民税        \"income_tax\": 100200,        \"per_capita_tax\": 3000,        \"allowances\": {          \"from_tax\": 0,          \"from_income\": 990000        },        \"rate\": 0.06,        \"taxable\": 1670000,        \"income\": 2660000,        \"total\": 103200 # 都道府県民税額      },      \"prefectural\": {  # 市町村民税        \"income_tax\": 66800,        \"per_capita_tax\": 1000,        \"allowances\": {          \"from_tax\": 0,          \"from_income\": 990000        },        \"rate\": 0.04,        \"taxable\": 1670000,        \"income\": 2660000,        \"total\": 67800  # 市町村民税額      }    },    \"income_tax\": {   # 所得税      \"taxable_allowances\": 97500,      \"allowances\": {        \"from_tax\": 0,        \"from_income\": 1140000      },      \"rate\": 0.1,      \"taxable\": 2600000,      \"income\": 3740000,      \"total\": 162500  # 所得税額    }  },  \"data\": { ... },  \"options\": {    \"dependents\": [      \"17\",      \"13\"    ],    \"spouse\": 37,    \"year\": 2013,    \"income\": 4000000,    \"annual_salary\": 4000000  }}詳しい仕様については、README をご確認ください。なお、現在開発中ですので、途中で仕様が変更される可能性があります。また不具合がある恐れもありますので、あらかじめご了承ください。Civic Techに関わって感じたことこの Advent Calendar のテーマは Civic Tech ですので、このことにも簡単に触れておきます。Civic Tech とは何ぞやということについては、1日目の関さんはじめ、皆さんがすでに書かれているのでそちらをご参考いただくとして、ここでは 1人のWebエンジニアとして Civic Tech に（多少ですが）関わることになった経緯と、その中で感じたことを書いてみたいと思います。私が Civic Tech に興味を持つようになったきっかけは、spending.jpのプロジェクトでした。4月に会社を退職し、東京から地元である大阪に戻ってフリーランスになったのですが、ちょうど自分が払う税金に対して関心が高くなっていた時期にこのプロジェクトを知り、その趣旨に共感して7月1日に大阪府吹田市版を立ち上げました。数日後にWHERE DOES MY MONEY GO?で使われている SVGアイコンを一覧で確認できるサイトを公開しました。MLで報告したところ、OpenSpending 本家にも報告してみてはというアドバイスをいただき、拙い英語でメールを投稿した結果、https://github.com/openspending/openspendingjs にリンクを張ってもらえることになりました。.@jmblog created an amazing selection of icons for Where Does My Money Go? sites http://t.co/8CgAD6itRs #openspending— OpenSpending (@openspending) 2013, 11月 10それに気を良くして、今度は OpenSpending の GitHubリポジトリで見つけた Taxman の日本版を作ってみようと思いたち、開発するに至りました。現在も OpenSpending のテクニカルリーダーと Taxman の仕様の共通化について GitHub 上で議論をしていたりします。OpenSpending の方々との慣れない英語でのコミュニケーションにはいつも時間がかかってしまいます。また、秋からはスタートアップ企業で働いており、開発時間もあまり取れなくなってしまいました。それでも、これからも継続的にこういった活動をしていきたいと考えています。そのモチベーションになっているのが、「自分のスキルで多少なりとも社会貢献できている」という思いと、「OSS（オープンソースソフトウェア）のコミッターとして世界とのつながりが広がっていく」という実感です。向こうの方々がすごく褒め上手なのも、活動の原動力になっているかもしれません。Civic Tech について興味はあるけど、何をしたらいいかわからないというエンジニアやデザイナーの方がいらっしゃるかもしれませんが、あまり深く考えすぎずに、小さなことでもいいので、自分にできそうなことを見つけて、実際に手を動かしてみることから始めてみてはいかがでしょうか？思いがけない世界が広がっていくかもしれませんよ。最後に今後は、引き続き Taxman の開発や、Taxmanを使った新しい「税金はどこに行った」サイトのテンプレートを開発できたらなと考えています。もし開発にご協力いただける方がいらっしゃいましたら、是非ご連絡ください！","link":"https://qiita.com/jimbo/items/9604f92795c24a7e8cb1","isoDate":"2013-12-06T14:54:20.000Z","dateMiliSeconds":1386341660000,"authorName":"jimbo","authorId":"jimbo"},{"title":"最も簡単なOpenSpending用のデータの作り方","contentSnippet":"OpenSpendingへの予算データの登録方法 では Excelを使った入力方法が紹介されていますが、CSVの作成と公開には Googleドキュメントのスプレッドシート を使った方が何かと便利なのでオススメです。（Windows PC での「Spending.jp クローンサイトの立ち上げ手順 (OpenSpending 対応版)」実行マニュアルでチラッと紹介されています。）メリット文字コードを気にしなくてよい。（メモ帳で開いて、文字コードをUTF-8に変更して保存し直す、という作業が不要。）公開するためのサーバーを用意しなくてよい。（Dropbox などにアップする作業が不要。）データの入力やチェックを複数人で協業しやすい。作成方法スプレッドシートを新しく開きます。データを入力します。項目や注意事項は OpenSpendingへの予算データの登録方法 と同じです。公開方法1.「ファイル」メニューの「ウェブに公開...」を選びます。2.「公開開始」ボタンをクリックして公開状態にします。3.「公開データへのリンクを取得」がアクティブになるので、「CSV（カンマ区切り値）」を指定します。一番下のURLがCSVデータの公開用URLです。これをOpenSpending への登録に利用します。あとは、OpenSpendingへの予算データの登録方法 に従って、データを登録して下さい。","link":"https://qiita.com/jimbo/items/a804177b1898e6379fe8","isoDate":"2013-07-21T10:10:52.000Z","dateMiliSeconds":1374401452000,"authorName":"jimbo","authorId":"jimbo"},{"title":"Sass の if 関数","contentSnippet":"これは CSS Preprocessor Advent Calendar 2012 の 5 日目の記事です。今日はあまり知られていない Sass の if 関数について紹介したいと思います。Sass には、条件分岐のための制御構文として @if ディレクティブ（いわゆる if 文）が用意されています。$type: ocean;p {  @if $type == ocean {    color: blue;  } @else {    color: black;  }}Sass の紹介記事の中では必ずと言っていいほど出てきますし、皆さんも一度は使ったことがあるのではないでしょうか。実はこの @if ディレクティブ以外に、Sass には if 関数が標準で用意されています。上のコードを if 関数を使って書き直すと、次のようになります。$type: ocean;p {  color: if($type == ocean, blue, black);}1 行で非常に簡潔に書くことができました。🙂@if ディレクティブとの一番の違いは、値でしか利用できない点です。例えば、次のようにプロパティごと返そうとしてもエラーになります。$type: ocean;p {  if($type == ocean, color: blue, color: black);}複数の条件分岐があるケースはこのようになります。ただし、コードの可読性が落ちるので、素直に @else if を使ったほうがよいように思います。$type: monster;p {  color: if($type == ocean, blue, if($type == matador, red, black));}このように、使い道は @if ディレクティブよりも限定されますが、うまく使うと、スマートにコードを書くことができます。例えば、以下は Compass の中で実際に使われている事例です。@mixin transform-origin(  $origin-x: $default-origin-x,  $origin-y: $default-origin-y,  $origin-z: false,  $only3d: if($origin-z, true, false)) {  $origin: unquote('');  @if $origin-x or $origin-y or $origin-z {    @if $origin-x {      $origin: $origin-x;    } @else {      $origin: 50%;    }    @if $origin-y {      $origin: $origin $origin-y;    } @else {      @if $origin-z {        $origin: $origin 50%;      }    }    @if $origin-z {      $origin: $origin $origin-z;    }    @include apply-origin($origin, $only3d);  }}第 4 引数 $only3d の初期値は、第 3 引数 $origin-z の値によって true か false がセットされるようになっていますが、if 関数を使うことで非常にわかりやすいコードになっているのが見てわかるかと思います。というわけで、if 関数の紹介でした。","link":"https://jmblog.jp/posts/2012-12-05/sass-if-function","isoDate":"2012-12-05T00:00:00.000Z","dateMiliSeconds":1354665600000,"authorName":"jimbo","authorId":"jimbo"},{"title":"innerHTML や jQuery.html() は HTMLをそのまま取得できるわけではない","contentSnippet":"element.innerHTML を使うと、その要素内の HTML を取得することができます。Mozilla Developer Network (MDN) には次のように書いてあります。innerHTML は、与えられた要素に含まれる全てのマークアップ と内容を設定または取得します。-- element.innerHTML – MDC Doc Center よりまた、jQuery.html() も、innerHTML と同様、HTML を取得することができます。Get the HTML contents of the first element in the set of matched elements.-- .html() – jQuery API よりでも、これらのメソッドを使っても、HTML のソースをそのまま取得できるわけではないことをご存知でしたか？私は知らずにハマってしまいました。ということで、以下、調べてみた結果です。例 1\u003cdiv id=\"main\"\u003e  \u003cul\u003e    \u003cli\u003ecoffee\u003c/li\u003e    \u003cli\u003ecoke\u003c/li\u003e    \u003cli\u003ered bull\u003c/li\u003e  \u003c/ul\u003e\u003c/div\u003e\u003cscript\u003e  var html = document.getElementById('main').innerHTML;  console.log(html);\u003c/script\u003eこの例では、次のような期待通りの HTML が返ってきます。\u003cul\u003e  \u003cli\u003ecoffee\u003c/li\u003e  \u003cli\u003ecoke\u003c/li\u003e  \u003cli\u003ered bull\u003c/li\u003e\u003c/ul\u003e例 2しかし、次の場合はどうでしょうか？\u003cdiv id=\"main\"\u003e  \u003cp\u003e\u003cdiv\u003efoo\u003c/div\u003e\u003c/p\u003e\u003c/div\u003e\u003cscript\u003e  var html = document.getElementById('main').innerHTML;  console.log(html);\u003c/script\u003eコンソールに出力されるのは\u003cp\u003e\u003cdiv\u003efoo\u003c/div\u003e\u003c/p\u003eだと期待するかもしれませんが、実際は\u003cp\u003e\u003c/p\u003e\u003cdiv\u003efoo\u003c/div\u003e\u003cp\u003e\u003c/p\u003eという文字列が返ってきます。jQuery.html() の場合も同じ結果になります。なぜこのようなことが起こるのでしょうか？不思議に思い、Quora で質問を投げてみました。すると、すぐにどなたかが答えてくれました。（Quora すげー！）また、Twitter でも同様の質問を投げてみたところ、@hogenishi1122 さんが答えてくれました。（感謝！）innerHTML や jQuery.html() は HTML のソースをそのまま返すわけではなく、ブラウザが一度 DOM ツリーに変換したものを返すとのこと。従って、invalid な HTML コードだと、ブラウザが解釈した DOM ツリーが返ってくるというわけでした。invalid な HTML を書かなければ、さほど問題にはならないかもしれませんが、必ずしも世の中がすべて valid だとは限りません。記憶の片隅に留めておけば、無用な苦労をすることもないかと思います。","link":"https://jmblog.jp/posts/2011-03-21/innerHTML-returns-serialized-html","isoDate":"2011-03-21T00:00:00.000Z","dateMiliSeconds":1300665600000,"authorName":"jimbo","authorId":"jimbo"},{"title":"cronが設定した時間どおりに実行されない場合の対処法","contentSnippet":"cron が crontab で設定した時間どおりに実行されないという現象に出くわして困ったのですが、何とか解決できたのでその方法を紹介しておきます。まず、以下のような設定（1 分ごとに実行）をしてみると、期待したとおりに動いている様子。* * * * * date \u003e\u003e /path/to/cron_check.txt次に、以下のような設定（14 時台で 1 分毎に実行）をしてみると、14 時台にも関わらず実行されません。* 14 * * * date \u003e\u003e /path/to/cron_check.txtもしかしてタイムゾーンがズレているのかも、と思い、次のように仕込んでみました。* 0 * * * echo '0' \u003e\u003e /path/to/cron_check.txt* 1 * * * echo '1' \u003e\u003e /path/to/cron_check.txt* 2 * * * echo '2' \u003e\u003e /path/to/cron_check.txt* 3 * * * echo '3' \u003e\u003e /path/to/cron_check.txt　　：* 22 * * * echo '22' \u003e\u003e /path/to/cron_check.txt* 23 * * * echo '23' \u003e\u003e /path/to/cron_check.txtすると 14 時台なのに、cron_check.txt に出力されたのは「0」。やはりタイムゾーンが狂ってるっぽいです。NetBSD で cron の動作時間がずれる - CORY's twilight zone を参考にして、crontab の先頭にTZ=\"Japan\"を追記してから$ sudo /sbin/service crond restartで cron のサービスを再起動したところ、無事、時間通りに実行されるようになったのでした。（TZ=\"Japan\" の代わりに CRON_TZ=\"Japan\" としてもうまくいきました。）もし、同じような問題に出会った方は試してみてください。","link":"https://jmblog.jp/posts/2010-12-24/cron-does-not-run-on-time","isoDate":"2010-12-24T00:00:00.000Z","dateMiliSeconds":1293148800000,"authorName":"jimbo","authorId":"jimbo"},{"title":":link、:visited、:hover、:active の記述順序とその覚え方","contentSnippet":"スタイルシートでa要素のリンクのデザインをする際に、次のように 4 つの擬似クラスを用いることが多いと思います。a:link {  color: blue;}a:visited {  color: purple;}a:hover {  color: red;}a:active {  color: yellow;}実はこの 4 つの擬似クラスの記述順序には注意が必要で、linkvisitedhoveractiveの順番で記述しないと意図した結果にならなかったりします。この順序についてちょっと調べてみたので、まとめてみたいと思います。なぜこの順番じゃなければダメなのか？実践 Web Standards Design には、次のように書かれています。:hover 擬似クラスと:active 擬似クラスは一連の動作であるので、スタイルシート内でもこの順番で記述しないと有効にならない点に注意してください。--「3 章 3.3/CSS 管理のコツ」より擬似クラスの記述順序には注意が必要です。（略）常に最後の指定で上書きされるということに注意し、link、visited、hover、active の順番で記述しておくと問題ないでしょう。逆に、すでに訪問済みのリンクは背景画像を変えたくないということであれば、visited を最後に記述するとよいでしょう。-- 「7 章 16/背景画像を利用して訪問済みリンクを一工夫する」より擬似クラスの記述順序にルールがあるというのを知ったのは、実はこの本がきっかけでした。それまでは「hover が効かない！」とか「訪問済みのリンクの色が変わらない！」とかいった問題に出くわしてハマッた経験が何度かあったので、書く順番が原因だったことがわかったときは思わず「そうだったのか！」とひざを打ってしまいました。で、勢いづいてもう少し調べてみると、CSS の権威である Eric Meyer 氏のサイトでも同じ内容に関する解説を見つけました。🔗 Link Specificity – meyerweb.comカンタンにまとめてみると、セレクタの固有性（specificity）は 4 つとも同じ。なので、最後に書かれたものから優先的に適用される。例えば、link、active、hover、visited の順番で記述しているとすると・・・未訪問リンクの場合は、active を hover が打ち消すので active は無効になる。従って、active は hover の後ろに記述しなければならない。訪問済みリンクの場合は、active も hover も一番最後の visited が打ち消してしまって無効になる。従って、visited は hover や active の前に記述しなければならない。つまり、link、visited、hover、active の順番で書くべし。ちなみに、link と visited は打ち消しあうことがないので順番はどっちでも OK。link はあくまで「未訪問（unvisited）」のリンクのみに適用される擬似クラスで、「リンク全般」に適用されるものじゃないので要注意。link じゃなくて unvisited にすればいいのにね。順番の覚え方海外では、この記述順序ルールを link-visited-hover-active の頭文字をとって「LVHA」と言うようです。ちょっと覚えづらいなぁと思っていたのですが、たまたま見かけた海外のブログにうまい覚え方が紹介されていました。🔗 How To Remember The Order of Selectors: LOVE and HATE – CSS TricksJust think 'LOVE' (LV) and 'HATE' (HA)....LOVE and HATE かぁ。ちょっと意味深だし覚えやすいですね。","link":"https://jmblog.jp/posts/2007-09-25/link-visited-hover-active","isoDate":"2007-09-25T00:00:00.000Z","dateMiliSeconds":1190678400000,"authorName":"jimbo","authorId":"jimbo"},{"title":"Firefoxでオートコンプリートの候補リストから削除する方法","contentSnippet":"ブラウザには、ログイン画面などのフォームで入力した内容を保存して、次回の入力時に自動で候補リストとして表示してくれる「オートコンプリート」という機能があります。とても便利な機能なのですが、一度間違って入力してしまった場合でも候補リストに残ってしまうのが、ちょっと困りものです。Firefox では、次のキーを押すことでオートコンプリートの候補リストから削除することができます。MacOS の場合： Shift + DeleteキーWindows の場合： Delete キー下記のサポートページに詳しい方法が載っているのでご参照ください。すべての入力履歴を消す方法や、オートコンプリートの機能を無効にする方法も紹介されています。参考：フォームの自動補完 | Firefox ヘルプ","link":"https://jmblog.jp/posts/2006-08-06/how-to-clear-form-history-on-firefox","isoDate":"2006-08-06T00:00:00.000Z","dateMiliSeconds":1154822400000,"authorName":"jimbo","authorId":"jimbo"}]},"__N_SSG":true},"page":"/members/[id]","query":{"id":"jimbo"},"buildId":"eZvXWM_4jTq2d5b2Beal6","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["link",{"rel":"icon shortcut","type":"image/png","href":"https://blog.ubie.tech/logo.png"}],["link",{"rel":"stylesheet","href":"https://fonts.googleapis.com/css2?family=Inter:wght@400;700\u0026display=swap"}],["title",{"children":"jimbo | Ubie Engineers' Blogs"}],["meta",{"property":"og:title","content":"jimbo"}],["meta",{"property":"og:url","content":"https://blog.ubie.tech/members/jimbo"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"property":"og:site","content":"Ubie Engineers' Blogs"}],["meta",{"property":"og:image","content":"https://blog.ubie.tech/og.png"}],["link",{"rel":"canonical","href":"https://blog.ubie.tech/members/jimbo"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-fa276ba060a4a8ac7eef.js"></script><script src="/_next/static/chunks/main-8a83f0fd99327c4684a8.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" async=""></script><script src="/_next/static/chunks/commons.8d61253ae98ee51657b8.js" async=""></script><script src="/_next/static/chunks/pages/_app-49079e3278dd6cef7229.js" async=""></script><script src="/_next/static/chunks/81b50c7ab23905e464b4340eb234bd6ea389d26b.dccc213aaaf4627fbcd3.js" async=""></script><script src="/_next/static/chunks/pages/members/%5Bid%5D-f279413a3daf3c18264d.js" async=""></script><script src="/_next/static/eZvXWM_4jTq2d5b2Beal6/_buildManifest.js" async=""></script><script src="/_next/static/eZvXWM_4jTq2d5b2Beal6/_ssgManifest.js" async=""></script></body></html>