<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon shortcut" type="image/png" href="https://blog.ubie.tech/logo.png"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap"/><title>soup | Ubie Engineers&#x27; Blogs</title><meta property="og:title" content="soup"/><meta property="og:url" content="https://blog.ubie.tech/members/soup"/><meta name="twitter:card" content="summary_large_image"/><meta property="og:site" content="Ubie Engineers&#x27; Blogs"/><meta property="og:image" content="https://blog.ubie.tech/og.png"/><link rel="canonical" href="https://blog.ubie.tech/members/soup"/><link rel="preload" href="/_next/static/css/5b1e5c056c67d836f701.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5b1e5c056c67d836f701.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-8a83f0fd99327c4684a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8d61253ae98ee51657b8.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-49079e3278dd6cef7229.js" as="script"/><link rel="preload" href="/_next/static/chunks/81b50c7ab23905e464b4340eb234bd6ea389d26b.c1e82b0cf4d92cbc3d75.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/members/%5Bid%5D-f279413a3daf3c18264d.js" as="script"/></head><body><div id="__next"><header class="site-header"><div class="content-wrapper"><div class="site-header__inner"><a class="site-header__logo-link" href="/"><img src="/logo.png" alt="Ubie Engineers&#x27; Blogs" class="site-header__logo-img"/><span class="site-header__logo-text">Ubie<br/>Engineers&#x27; Blogs</span></a><div class="site-header__links"><a href="https://ubie.life/" class="site-header__link" target="_blank">Company</a><a href="https://recruit.ubie.life/jd_dev" class="site-header__link" target="_blank">Recruit</a></div></div></div></header><section class="member"><div class="content-wrapper"><header class="member-header"><div class="member-header__avatar"><img src="/avatars/soup.png" alt="soup" width="100" height="100" class="member-header__avatar-img"/></div><h1 class="member-header__nickname">soup</h1><p class="member-header__real-name">souppower</p><p class="member-header__bio">強い犬</p><div class="member-header__links"><a href="https://twitter.com/souppower" class="member-header__link"><img src="/icons/twitter.svg" alt="Twitterのユーザー@souppower" width="22" height="22"/></a><a href="https://github.com/souppower" class="member-header__link"><img src="/icons/github.svg" alt="GitHubのユーザー@souppower" width="22" height="22"/></a><a href="https://qiita.com/souppower" class="member-header__link"><img src="/icons/link.svg" alt="ウェブサイトのリンク" width="22" height="22"/></a></div></header><div class="member-posts-container"><div class="post-list"><article class="post-link"><a class="post-link__author" href="/members/soup/"><img src="/avatars/soup.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">soup</div><time dateTime="2020-06-17T09:35:43.000Z" class="post-link__date">a year ago</time></div></a><a href="https://qiita.com/souppower/items/69be0f53da1c6bcfda4e" class="post-link__main-link"><h2 class="post-link__title">プロトタイピングと負債、リスクについて</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/soup/"><img src="/avatars/soup.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">soup</div><time dateTime="2020-05-29T09:05:19.000Z" class="post-link__date">a year ago</time></div></a><a href="https://qiita.com/souppower/items/0abe143650051d733de9" class="post-link__main-link"><h2 class="post-link__title">[Jest] DIしたオブジェクトのメソッド呼び出しをテストする</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/soup/"><img src="/avatars/soup.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">soup</div><time dateTime="2020-05-12T04:33:56.000Z" class="post-link__date">a year ago</time></div></a><a href="https://qiita.com/souppower/items/c7f8b2174383f487b514" class="post-link__main-link"><h2 class="post-link__title">フロントエンドにClean Architectureが要らないかもしれない話</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/soup/"><img src="/avatars/soup.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">soup</div><time dateTime="2020-04-16T12:53:32.000Z" class="post-link__date">a year ago</time></div></a><a href="https://qiita.com/souppower/items/c2d447172c2bc716f94c" class="post-link__main-link"><h2 class="post-link__title">faviconは難しい</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/soup/"><img src="/avatars/soup.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">soup</div><time dateTime="2020-03-17T11:26:29.000Z" class="post-link__date">a year ago</time></div></a><a href="https://qiita.com/souppower/items/ad1ac2431fdb136455f8" class="post-link__main-link"><h2 class="post-link__title">ゲッターとセッター、そして temporal coupling</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/soup/"><img src="/avatars/soup.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">soup</div><time dateTime="2018-12-25T02:55:33.000Z" class="post-link__date">3 years ago</time></div></a><a href="https://qiita.com/souppower/items/e16b945d4eafcf9f37a0" class="post-link__main-link"><h2 class="post-link__title">Web FrontendでClean Architectureを試す</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/soup/"><img src="/avatars/soup.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">soup</div><time dateTime="2017-11-30T04:20:31.000Z" class="post-link__date">4 years ago</time></div></a><a href="https://qiita.com/souppower/items/cd83f68f148fc23ffe7a" class="post-link__main-link"><h2 class="post-link__title">Lighthouseでwebサイトのパフォーマンスを計測する</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/soup/"><img src="/avatars/soup.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">soup</div><time dateTime="2016-12-18T17:41:58.000Z" class="post-link__date">5 years ago</time></div></a><a href="https://qiita.com/souppower/items/d3b66a2a323ff27f53f1" class="post-link__main-link"><h2 class="post-link__title">ソーシャルログインをAngularとFirebase Authenticationで簡単に作る</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/soup/"><img src="/avatars/soup.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">soup</div><time dateTime="2016-10-28T07:47:24.000Z" class="post-link__date">5 years ago</time></div></a><a href="https://qiita.com/souppower/items/43e5a1f31505e91171cb" class="post-link__main-link"><h2 class="post-link__title">Angular-cliのproxy設定</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article><article class="post-link"><a class="post-link__author" href="/members/soup/"><img src="/avatars/soup.png" class="post-link__author-img" width="35" height="35"/><div class="post-link__author-name"><div class="post-link__author-name">soup</div><time dateTime="2016-05-07T05:54:18.000Z" class="post-link__date">5 years ago</time></div></a><a href="https://qiita.com/souppower/items/c83a13f22196f6459092" class="post-link__main-link"><h2 class="post-link__title">[Go]Goインストールからツイート投稿まで3分クッキング</h2><div class="post-link__site"><img src="https://www.google.com/s2/favicons?domain=qiita.com" width="14" height="14" class="post-link__site-favicon"/>qiita.com</div></a></article></div></div></div></section><footer class="site-footer"><div class="content-wrapper"><p>© <!-- -->Ubie Discovery</p></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"member":{"id":"soup","nickname":"soup","realName":"souppower","bio":"強い犬","avatarSrc":"/avatars/soup.png","sources":["https://qiita.com/souppower/feed"],"includeUrlRegex":"https://qiita.com/souppower","twitterUsername":"souppower","githubUsername":"souppower","websiteUrl":"https://qiita.com/souppower"},"postItems":[{"title":"プロトタイピングと負債、リスクについて","contentSnippet":"こんにちはスープです。スタートアップのお手伝いをしています。プロトタイピング価値検証のために、実装とリリース、ユーザーフィードバック収集のサイクルを繰り返し行います。そのサイクルのスピードと精度が重要です。メンテンナンス性を度外視できる場合コードは書かれるよりも、人に読まれる時間のほうが長いので、一般的にきちんとした設計のコードを書くメリットは大きいです。ただし、書き捨てのコードに限っては、動作すれば何でも良いため、基本的にどんな書き方でも支障がないです。これはプロトタイピング用のコードに関しても同じことが言えますね。リスク中長期的な成長の阻害問題になるのは、プロトタイピング目的で書かれたコードをメンテナンスしなければいけないときです。プロトタイピングフェーズ後、目下のビジネス価値の実現のみにエンジニアリングリソースが割かれることは非常に多く、スケールしない設計のまま突き進んでしまうケースが多いのです。設計のひずみが日増しに大きくなり、3年もすると（早ければ半年程度で）身動きが取れない状態になります。バッドコードにより、機能開発に必要なリソースは指数関数的に増えていきます。また、フラストレーションを溜めた離職者が続出したり、プロダクトの成長が止まったりすることは日常茶飯事で、会社ごと吹き飛んだりするケースもあるらしいです。訴訟、ブランド毀損低品質なソフトウェアによってユーザーが損害を被った場合、訴訟に発展したり、それによってブランドイメージを毀損したりするリスクが存在します。Uberの自動運転で死者を出す事故が起きているのは記憶に新しいですね。リスクにどう対処するか負債の管理負債の性質と量を把握し、負債返済のロードマップを作成する必要があります。また、負債を増やすステークホルダーの要求があった場合、開発者はそのリスクを指摘します。ステークホルダーのほとんどの人たちは、負債によって発生するリスクを知らないので、当該システムのことを知っているプログラマーにその責任がありますね。一般的に、CTOやソフトウェアアーキテクト、テックリード等がソフトウェアのアーキテクチャへの影響をコントロールする役割を率先して担えるでしょう。変更によって増す複雑性とそれによって追加される機能性を天秤にかけ、機能性の方が低いと判断される場合は、その変更は受け入れられません。ステークホルダーとのコミュニケーションプロトタイピングフェーズである旨をステークホルダー皆が認識する必要があります。価値検証が終わったら、後にソフトウェアのリライト（フルリライトもしくはパーシャルなリライト）をすることをチーム全体、またステークホルダー達と握っておく必要があります。ステークホルダーには、下記の人たちが含まれるはずです。CEO投資家PO開発チームSalesチームその他影響を受けるチームエンドユーザーまとめソフトウェアがどのフェーズに位置しているかを理解するのは重要ですね。リスクを管理し、適切にステークホルダーとコミュニケーションを取っていくことによって、ソフトウェアが成功する確率を高めることができると思います。","link":"https://qiita.com/souppower/items/69be0f53da1c6bcfda4e","isoDate":"2020-06-17T09:35:43.000Z","dateMiliSeconds":1592386543000,"authorName":"soup","authorId":"soup"},{"title":"[Jest] DIしたオブジェクトのメソッド呼び出しをテストする","contentSnippet":"こんにちは、スープです。医療テックのスタートアップのお手伝いをしています。DIしたオブジェクトのメソッド呼び出し方法を調べました。わかりやすくするために、シンプルな例を示します。export class CarFactory {  constructor(private logger: ILogger) {}  public create(name: string): void {    this.logger.log(`creating ${name} car...`)  }}このとき、コンストラクターインジェクションされた logger の log が呼ばれていることをテストしてみます。describe('CarFactory', () =\u003e {  test('create', () =\u003e {    const logger = new Logger();    const carFactory= new CarFactory(logger);    const spy = jest.spyOn(logger, 'log');    // オプショナルで、Logger.log の挙動を指定したい場合は mockImplementation を呼ぶ    spy.mockImplementation(() =\u003e console.log('log is being called'));    const carName = 'Toyota'    carFactory.create(carName);    // 呼び出されていることをチェック    expect(logger.log).toHaveBeenCalled();    // 想定通りの引数で呼び出されていることをチェック    expect(logger.log).toHaveBeenCalledWith(`creating ${carName} car...`);    // これでリセットできる    spy.mockRestore();  });});参考","link":"https://qiita.com/souppower/items/0abe143650051d733de9","isoDate":"2020-05-29T09:05:19.000Z","dateMiliSeconds":1590743119000,"authorName":"soup","authorId":"soup"},{"title":"フロントエンドにClean Architectureが要らないかもしれない話","contentSnippet":"こんにちは、スープです。フロントエンドでクリーンアーキテクチャをやっています。近頃、フロントエンドにはクリーンアーキテクチャ（以下CA）は不要なのでは、という説が自分の中で持ち上がっているので、その話をします。前提複雑度がそれほど高くないSPAなフロントエンドアプリケーションの話です。なぜ不要かもしれないかフロントエンドで表現するべき「ユースケース」が不在だからコントローラーは冗長なMiddle Manだからプレゼンテーション層と相性が悪いから1. フロントエンドで表現するべき「ユースケース」が不在だからユースケースの役割ユースケース層は、ドメインロジックのオーケストレーションを担い、ソフトウェアのユースケースを表現します。例えば、「ユーザーを作成する」や「商品を購入する」のようなものです。ソースコード全体を見なくても、ユースケースを見るだけで、何を解決するソフトウェアか理解できるべきでしょう。Entityのドメインオブジェクトを組み合わせて処理の流れを作るレポジトリの操作読み書き処理が何発も走ることがある（Emailの重複を確認して、ユニークならユーザー登録させるとか）CQRSならレポジトリの操作がさらに増えるフロントエンドでのユースケースバックエンドとフロントエンドの責務の切り方は様々にあり、それ次第でフロントエンドのユースケースに対する考え方は変わってきそうです。そのため、プロダクトごとに設計を検討する必要があります。API側にビジネスロジックが寄っている場合は、フロントエンドで表現するべきユースケースが不在なことがあります。バリデーションすべき値がほとんどなかったり、単純なレポジトリの呼び出しのみしかやることがなく、その場合はユースケース層の存在意義が影を潜めます。「記事をお気に入り登録する」を例に取ります。お気に入り登録APIを呼ぶ（レポジトリ操作）成功したら成功した旨を返却する成功したら不成功理由を返却する少し極端な例かもしれませんが、ただ単純にAPIを呼ぶだけですね。フロントエンドでやれることは他に特にありませんね。これくらい薄いユースケースなら、直接コンポーネントからレポジトリを呼べたほうが良さそうに見えます。ユースケースを準備する冗長さを飲む気になれません。ユースケースが使える場合もある「ユーザーを作成する」だと…バリデーションEmail のフォーマットが適切かパスワードの長さが適切かユーザー作成APIを呼ぶ（レポジトリ操作）成功したらストアにユーザー情報を詰める（レポジトリ操作）ユーザー情報を返却する成功したら不成功理由を返却する「商品を購入する」だと…バリデーションクレカの期限切れチェック商品購入APIを呼ぶ（レポジトリ操作）購入が成功したらカートを空にする購入情報を返却する不成功だったら不成功理由を返却するこれらの例のように、複雑性が増してくると、ユースケース層の導入意義が増してきそうですね。処理の流れを抽象的に管理したくなるからです。ただし、コンポーネント側でバリデーションした上で呼び出すという契約にする場合は、ユースケースでのバリデーションは不要になりますね。ドメインオブジェクトの呼び出しが減るため、ユースケース層の存在意義が減りそうです。2. コントローラーは冗長なMiddle Manだから入出力の型変換を行うくらいで、あとはユースケースを呼び出すのみで、非常に薄い Middle Manです。Martin Fowler 氏の Refactoring に出てくる Remove Middle Man ができそうです。https://refactoring.com/catalog/removeMiddleMan.htmlドメインロジックをビューに漏れ出させないために、ここでDTOに詰め替えて返却する必要があると思っていました。でもそんなことはフロントエンドでは基本的になく、ビューではDTOではなく、ドメインオブジェクトを扱えるほうが都合が良いことの方が多いです。むしろ、表示をメインの責務としているフロントエンドにおいては、表示で使うロジックをドメインオブジェクトに抽出するのだと今は考えています。3. プレゼンテーション層と相性が悪いからUncle BobのFlow Of Controlによると、コントローラーから呼び出されたInteractorが内部でプレゼンテーションを呼び出し、プレゼンテーション経由で元の呼び出し元に直接応答するようになっているみたいです。コントローラーが呼び出されているのに、代わりにプレゼンテーションが直接呼び出しに応答するというのが、web通信を挟まない環境では実際的ではないかと思われます。じゃあどうしよう我々が欲しかったのは、CAというよりかは、変更の影響の見通しの良さではないでしょうか。以下は案の一つです。当然ですが、プロダクトの性質によって適切な設計は変わってきます。コントローラー、プレゼンター、ユースケースは要らない。ドメインロジックのオーケストレーションが必要になることがあれば、そのときに初めてユースケース層を導入する（YAGNI）コンポーネントからレポジトリを呼ぶContext 等でレポジトリのインスタンスを渡せば良いレポジトリはドメインオブジェクトを返却するレイヤー数は2か3で事足りそうです。EntityValue Objectやドメインサービス等のドメインロジックRepository永続化ドメインオブジェクトを返却するInfrastractureビューロギング...ただし、ViewModelなどで行っていた、日付等のフォーマット操作をどうするかはまだ検討する必要があります。Entityに生やすか、Repositoryの戻り値をViewModelとするかになるでしょうか。いい案があれが教えてください。お気持ちCAに限った話ではないですが、どんなプリンシプルもそのエッセンスを抽出し、プロダクトの性質を踏まえた上で設計をしていく必要があります。銀の弾丸は存在せず、解決しようとする事柄に応じて最適な設計を探っていく必要がありそうです。また、抽象化等のソフトウェアの複雑性を高める決定は、その新たに生む複雑性を上回るメリットがあるなら受け入れられます。そのトレードオフを飲めない場合は、そのコードベースの複雑性を押し上げる決定は避けるのが賢明だと思われます。","link":"https://qiita.com/souppower/items/c7f8b2174383f487b514","isoDate":"2020-05-12T04:33:56.000Z","dateMiliSeconds":1589258036000,"authorName":"soup","authorId":"soup"},{"title":"faviconは難しい","contentSnippet":"svg アイコンが safari で読み込めない問題に直面した。調べたところ、svg アイコンは safari では partial support しかされていないらしかった。基本的に、favicon.ico を置いておけば、幅広くいろいろなブラウザで表示できるわけだが、この .ico は deprecated ならしい。favicon のベストプラクティスはこの stackoverflow の回答が詳しいので参照されたい。https://stackoverflow.com/questions/48956465/favicon-standard-2020-svg-ico-png-and-dimensions現代は目まぐるしく新しいデバイスが出現し、消えていく時代なので、あらゆるデバイスサイズに対応するのは人類には難しい。そのため、favicon の生成ツールを使うのが良いかと思われる。favicon をアップロードすれば、いろいろなサイズの favicon とそれに対応するタグとアイコンを生成してくれるサイトみたいだ。なんて頼もしいんだろう。","link":"https://qiita.com/souppower/items/c2d447172c2bc716f94c","isoDate":"2020-04-16T12:53:32.000Z","dateMiliSeconds":1587041612000,"authorName":"soup","authorId":"soup"},{"title":"ゲッターとセッター、そして temporal coupling","contentSnippet":"ゲッターとセッターオブジェクト志向(以下OO)では、ゲッターやセッターの使用は勧められていません。使用に際しては慎重さが求められます。これは、tell, don't ask という原則と関係しています。オブジェクトに対して状態を問い合わせる (ask) のではなく、処理を指示する (tell) ように実装するのが、OOらしい設計なのです。 https://martinfowler.com/bliki/TellDontAsk.html中でも、セッターの使用は特に避けたほうが良いと思われます。オブジェクトのミューテーションはバグの温床です。また、値がセットされているかの検査が乱発し、結果としてコードベースのメンテナンス性が低下します。temporal coupling一般的な日本語訳の存在を筆者は知らないのですが、「時系列依存」と訳せるかもしれません。特定の順序で呼び出される必要のある処理がある場合、それを temporal coupling と言います。適切にカプセル化されていたなら、このようなことは起きないです。この制約の存在は、得てしてベテランメンバーの頭の中だけに存在し、チームの暗黙知となります。セッターの使用は temporal coupling を生みます。例を擬似コードで示します。main() {     const user = new User()    user.setId(10) // repo.save(user) より前に必ず呼び出さないといけないので、これは termporal coupling    if (user.id) {        userRepo.save(user)    }}改善例main() {     // セッターを使わずに、初期化時にセットされることが保証されている    const user = new User({id: 10})    userRepo.save(user)}まとめゲッターとセッターの濫用はダメ、絶対。特定の順序で呼び出される必要がある処理について、アンチパターンとして temporal coupling という呼び名が付いている。","link":"https://qiita.com/souppower/items/ad1ac2431fdb136455f8","isoDate":"2020-03-17T11:26:29.000Z","dateMiliSeconds":1584444389000,"authorName":"soup","authorId":"soup"},{"title":"Web FrontendでClean Architectureを試す","contentSnippet":"こんにちは、スープです。EdTechビジネスのプラットフォームチームでエンジニアをしています。Clean ArchitectureでTodoアプリのFrontendを試作しました。良ければ実装をみてください。概要Clean Architectureでは、UIやDB、FWといったアプリケーションの詳細を、ビジネスルールから切り離し、プラグインとして実装します。これには、テスタビリティやコードのリーダビリティが高く保たれる等のメリットがあります。とはいえ最大のメリットは、詳細の決定を遅延できることかもしれません。詳細の決定を遅延できるということ開発初期には、すべてのユースケースを把握できないため、重大な決定は遅延できるのが望ましいです。開発が進むにつれて、適切な決定を下すための情報が数多く手に入るため、後回しにできるメリットは大きい。また、数多くの実験をする余裕を獲得するというメリットもあります。このメリットについては、Robert C. Martin 氏が度々強調しています。https://blog.cleancoder.com/uncle-bob/2011/11/22/Clean-Architecture.html実装TODOアプリの実装を手短に見ていきます。DomainTODOの型定義があるだけです。export interface Todo {  id: number;  title: string;}Usecaseアプリケーション固有のビジネスルールを書いています。渡された todoRepo にデータのやりとりの処理を委譲します。特定の実装に依存せず、interfaceに依存させることにより、ビジネスルールが外部の詳細を知らずにすみます。import { Todo } from \"domain\";import { TodoRepository } from \"./repository\";export default class TodoUsecase {  constructor(private todoRepo: TodoRepository) {}  findAll(): Todo[] {    return this.todoRepo.findAll();  }  add(text: string) {    this.todoRepo.add(text);  }  edit(id: string, text: string) {    this.todoRepo.edit(id, text);  }  finish(id: string) {    this.todoRepo.delete(id);  }  finishAll() {    this.todoRepo.deleteAll();  }}InterfacePresenterTODOアプリケーションの表示部分を司ります。import React from \"react\";import Usecase from \"usecase/todo\";import { Todo } from \"domain\";import { Input, Item, ClearButton } from \"./todos\";import \"./app.css\";interface Props {  usecase: Usecase;}interface State {  input: string;  todos: Todo[];}export default class App extends React.Component\u003cProps, State\u003e {  private usecase: Usecase;  constructor(props: Props) {    super(props);    this.usecase = this.props.usecase;    this.state = {      input: \"\",      todos: []    };  }  componentDidMount() {    const todos = this.usecase.findAll();    this.setState({ todos });  }  handleChange(e: any) {    this.setState({ input: e.target.value });  }  onKeyPress(e: any) {    if (e.key !== \"Enter\") {      return;    }    const input = e.target.value;    this.usecase.add(input);    this.setState({ input: \"\" });    const todos = this.usecase.findAll();    this.setState({ todos });  }  finishTodo(id: string) {    this.usecase.finish(id);    const todos = this.usecase.findAll();    this.setState({ todos });  }  clearTodos() {    this.usecase.finishAll();    this.setState({ todos: [] });  }  render() {    const { todos } = this.state;    return (      \u003csection className=\"todoapp\"\u003e        \u003cInput          value={this.state.input}          handleChange={this.handleChange.bind(this)}          onKeyPress={this.onKeyPress.bind(this)}        /\u003e        \u003csection\u003e          \u003cul className=\"list-group\"\u003e            {this.state.todos.map(todo =\u003e (              \u003cItem                key={todo.id}                todo={todo}                onFinish={this.finishTodo.bind(this)}              /\u003e            ))}          \u003c/ul\u003e          {todos.length \u003e 0 \u0026\u0026 (            \u003cdiv className=\"right-align\"\u003e              \u003cClearButton onClick={this.clearTodos.bind(this)} /\u003e            \u003c/div\u003e          )}        \u003c/section\u003e      \u003c/section\u003e    );  }}InfrastructureTODOの保存処理を書きました。Memory か LocalStorage 保存か選択できるように、 store は interface に依存させ、詳細ロジックはDIしてもらうようにしました。import Persistor from \"interface/repository/persistor\";export default class Store {  constructor(private store: Persistor) {}  get(key: string) {    return this.store.get(key);  }  getAll() {    return this.store.getAll();  }  save(value: any) {    this.store.save(value);  }  delete(id: string) {    this.store.delete(id);  }  clear() {    this.store.clear();  }}エントリーポイントそして最後にエントリーポイントです。usecase を組み立てて、 Presenter に渡しています。import React from \"react\";import ReactDOM from \"react-dom\";import { LocalStorage, Persistor } from \"infrastructure\";import { TodoRepository } from \"interface/repository\";import App from \"interface/presenter\";import { TodoUsecase } from \"usecase\";const storage = new LocalStorage(\"clean-architecure-todo\");const persistor = new Persistor(storage);const todoRepository = new TodoRepository(persistor);const usecase = new TodoUsecase(todoRepository);ReactDOM.render(\u003cApp usecase={usecase} /\u003e, document.getElementById(\"app\"));感想これからもやっていきたい。参考Front End Architecture — Making rebuild from scratch not so painfulJavaScriptでClean Architectureを導入してみた - Vue.js・ReactのサンプルつきClean ArchitectureClean Architecture in Web Frontend #mixleap","link":"https://qiita.com/souppower/items/e16b945d4eafcf9f37a0","isoDate":"2018-12-25T02:55:33.000Z","dateMiliSeconds":1545706533000,"authorName":"soup","authorId":"soup"},{"title":"Lighthouseでwebサイトのパフォーマンスを計測する","contentSnippet":"こんにちは、スープです。Prottというプロトタイピングツールのフロントエンドディベロッパーです。この記事ではGoogleが開発しているLighthouseというツールを紹介します。Lighthouseとはwebサイトのパフォーマンスやアクセシビリティ、WPA等のメトリクス測定ができるツールです。GithubのREADMEにはこうありました。Lighthouse analyzes web apps and web pages, collecting modern performance metrics and insights on developer best practices.Github：https://github.com/GoogleChrome/lighthouse公式ページ：https://developers.google.com/web/tools/lighthouse実行方法Chrome DevToolsChrome DevToolsのAuditsで Perform an audit... ボタンを押すだけです。押すとこんな風にメトリクスを出してくれます。Node CLIインストール$ yarn global add lighthouse計測$ lighthouse \u003curl\u003e$ lighthouse \u003curl\u003e --view # 結果をブラウザで見るPerformance測定メトリクスFirst Meaningful Paintページの主要なコンテンツがスクリーンに表示されるまでの時間。ユーザーの感じるローディング体験に直結する。詳細スペック：https://docs.google.com/document/d/1BR94tJdZLsin5poeet0XoTW60M0SjvOJQttKT-JK8HI/view#heading=h.k50nnyhtptq0First Interactiveページが最低限の操作を受け付けるようになるまでの時間。https://developers.google.com/web/tools/lighthouse/audits/first-interactiveConsistently Interactiveページが完全に操作を受け付けるようになるまでの時間。https://developers.google.com/web/tools/lighthouse/audits/consistently-interactivePerceptual Speed Indexページ内のコンテンツがどれほどはやくpopulateされるか。Estimated Input Latencyユーザーの入力に応答時間の予測。Opportunitiesパフォーマンス改善するために最適化するべきリソースを示してくれます。所感簡単にwebサイトの計測ができて改善点も教えてくれるLighthouseは、非常に頼もしい優れものです。CIでパフォーマンス計測し、mergeの可否判定をするのもいいかなと思います。参考リンクGithub：https://github.com/GoogleChrome/lighthouse公式ページ：https://developers.google.com/web/tools/lighthouseLighthouse CI：https://github.com/ebidel/lighthouse-ciHeadless Chrome：https://github.com/GoogleChrome/lighthouse/blob/master/docs/headless-chrome.md","link":"https://qiita.com/souppower/items/cd83f68f148fc23ffe7a","isoDate":"2017-11-30T04:20:31.000Z","dateMiliSeconds":1512015631000,"authorName":"soup","authorId":"soup"},{"title":"ソーシャルログインをAngularとFirebase Authenticationで簡単に作る","contentSnippet":"こんにちは、スープです。AngularとFirebaseを使ってソーシャルログインを簡単に作ってみます。Angular Authentication made easy with Firebase のやり方に倣って作っていきます。ステップFirebaseのプロジェクト作成環境設定コードを書くFirebaseのプロジェクト作成Firebaseのコンソールでプロジェクトを作成します。使用するSign-in providersを選択して有効にします。コード例ではGoogleとTwitterを利用しています。Authentication → SIGN-IN METHOD から使用するSign-in providersを有効にします。providerによって、Key/Secret等の設定が必要です。例えばTwitterなら、アプリの作成後、API KeyとAPI Secretを取得してきて、設定する必要があります。→Twitter Application Management環境設定angular-cliをインストール$ npm install -g angular-clianglar-cliでスキャフォルディング$ ng new firebase-auth-sample$ cd firebase-auth-sample開発サーバー起動$ ng servelocalhost:4200にブラウザでアクセスangularfire2とfirebaseのモジュールを入れます。$ npm install angularfire2 firebase --save$ npm install @types/firebase --save-devtsconfig.json にtypes追加コードを書くFirebaseのコンソールのWEB SETUPをクリックすると、ポップアップで設定が表示されるので、コピーしてapp.module.tsに貼り付けます。(※apiKeyが見えていますが、プロジェクトの識別に用いられるだけなので問題ありません)src/app/app.module.tsimport { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { FormsModule } from '@angular/forms';import { HttpModule } from '@angular/http';import {  AngularFireModule,  AuthMethods,  AuthProviders} from \"angularfire2\";import { AppComponent } from './app.component';// ポップアップの設定をここに貼り付けるconst firebaseConfig = {    apiKey: \"\u003cyour-apiKey\u003e\",    authDomain: \"\u003cyour-auth-Domain\u003e\",    databaseURL: \"\u003cyour-database-URL\u003e\",    storageBucket: \"\u003cyour-storage-Bucket\u003e\"};@NgModule({  declarations: [    AppComponent  ],  imports: [    BrowserModule,    FormsModule,    HttpModule,    AngularFireModule.initializeApp(firebaseConfig,{      provider: AuthProviders.Twitter,      method: AuthMethods.Popup      // method: AuthMethods.Redirect // Redirectが良いならこっち    })  ],  providers: [],  bootstrap: [AppComponent]})export class AppModule { }AngularFireのauthはobservableなので、subscribeするsrc/app/app.component.tsimport { Component } from '@angular/core';import { AngularFire, AuthProviders } from 'angularfire2';@Component({  selector: 'app-root',  templateUrl: './app.component.html',  styleUrls: ['./app.component.css']})export class AppComponent {  user = {};  constructor(public af: AngularFire) {    this.af.auth.subscribe(user =\u003e {      if(user) {        this.user = user;        console.log(this.user);      }      else {        this.user = {};      }    });  }  login(from: string) {    this.af.auth.login({      provider: this._getProvider(from)    });  }  logout() {    this.af.auth.logout();  }  private _getProvider(from: string) {    switch(from){      case 'twitter': return AuthProviders.Twitter;      case 'google': return AuthProviders.Google;    }  }}src/app/app.component.html\u003cbutton (click)=\"login('google')\"\u003e  Google Login\u003c/button\u003e\u003cbutton (click)=\"login('twitter')\"\u003e  Twitter Login\u003c/button\u003e\u003cbutton (click)=\"logout()\"\u003e  Logout\u003c/button\u003eここでログインボタンを押すと、ユーザーオブジェクトが返ってきて中身にいろいろな情報が入っているのが確認できました！(ง ˙ω˙)วFirebaseのコンソールからはユーザーの情報が確認できます。ユーザーの有効・無効化、停止もここから簡単にできます。コードはこちらに置いています。参考Angular Authentication made easy with FirebaseAngularfire2","link":"https://qiita.com/souppower/items/d3b66a2a323ff27f53f1","isoDate":"2016-12-18T17:41:58.000Z","dateMiliSeconds":1482082918000,"authorName":"soup","authorId":"soup"},{"title":"Angular-cliのproxy設定","contentSnippet":"Angular-cliを使っているプロジェクトで、フロントとAPIのローカル開発サーバーを分けていて、フロント側からAPIを呼ぶ場合の設定方法のメモproxy設定ファイルを書くproxy設定ファイルを指定してng serveする1. proxy設定ファイルを書くproxy.conf.json{  \"/api\": {    \"target\": \"http://localhost:8080\",    \"secure\": false  }}2. proxy設定ファイルを指定してng serveするpackage.json{  …  \"scripts\": {    \"start\": \"ng serve --proxy-config proxy.conf.json\"  },  …}$ npm start参考Proxy To Backend","link":"https://qiita.com/souppower/items/43e5a1f31505e91171cb","isoDate":"2016-10-28T07:47:24.000Z","dateMiliSeconds":1477640844000,"authorName":"soup","authorId":"soup"},{"title":"[Go]Goインストールからツイート投稿まで3分クッキング","contentSnippet":"Goの環境がない状態から、Goツイートするまでを3分間でやってみましょう。※コンシューマキーやアクセストークン等は既にあることを前提にしています。 未取得の場合は、https://apps.twitter.com/ にいって設定\u0026取得しましょう。Goの環境設定anacondaインストールツイート投稿コード作成Goの環境設定Goはこれだけで簡単に入っちゃいますbrew install goGoが入ったことを確認go --version次に、.bashrc等でPATHを設定しましょうexport GOROOT=/usr/local/opt/go/libexecexport GOPATH=$HOME/.goexport PATH=$PATH:$GOROOT/bin:$GOPATH/binanacondaインストールanacondaはTwitter 1.1 APIが扱えるライブラリーです。go get github.com/ChimeraCoder/anacondaツイートコード作成コード中のコンシューマキーやアクセストークンは、自分のものと置換してください。tweet.gopackage mainimport (        \"fmt\"        \"github.com/ChimeraCoder/anaconda\"        \"log\"        \"os\")func main() {  anaconda.SetConsumerKey(\"your-consumer-key\")  anaconda.SetConsumerSecret(\"your-consumer-secret\")  api := anaconda.NewTwitterApi(\"your-access-token\", \"your-access-token-secret\")  text := os.Args[1]  tweet, err := api.PostTweet(text, nil)  if(err != nil){    log.Fatal(err)  }  fmt.Println(tweet.Text)}ビルドしましょう。go build tweet.go同じディレクトリにtweetというバイナリファイルが生成されているはずです。では実行してみましょう。./tweet \"進捗どうですか？\"これでツイートが投稿できるはずです。実際にTwitterで確認してみてください。参考Go言語の開発環境セットアップ http://qiita.com/awakia/items/7bf03fd96a74502073b8情弱だがGoで画像付きツイートしたい http://qiita.com/stenpel/items/01f6ef20c4691564faa5","link":"https://qiita.com/souppower/items/c83a13f22196f6459092","isoDate":"2016-05-07T05:54:18.000Z","dateMiliSeconds":1462600458000,"authorName":"soup","authorId":"soup"}]},"__N_SSG":true},"page":"/members/[id]","query":{"id":"soup"},"buildId":"RH7Qjj9bKzOmFDwPBbN9a","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["link",{"rel":"icon shortcut","type":"image/png","href":"https://blog.ubie.tech/logo.png"}],["link",{"rel":"stylesheet","href":"https://fonts.googleapis.com/css2?family=Inter:wght@400;700\u0026display=swap"}],["title",{"children":"soup | Ubie Engineers' Blogs"}],["meta",{"property":"og:title","content":"soup"}],["meta",{"property":"og:url","content":"https://blog.ubie.tech/members/soup"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"property":"og:site","content":"Ubie Engineers' Blogs"}],["meta",{"property":"og:image","content":"https://blog.ubie.tech/og.png"}],["link",{"rel":"canonical","href":"https://blog.ubie.tech/members/soup"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-fa276ba060a4a8ac7eef.js"></script><script src="/_next/static/chunks/main-8a83f0fd99327c4684a8.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" async=""></script><script src="/_next/static/chunks/commons.8d61253ae98ee51657b8.js" async=""></script><script src="/_next/static/chunks/pages/_app-49079e3278dd6cef7229.js" async=""></script><script src="/_next/static/chunks/81b50c7ab23905e464b4340eb234bd6ea389d26b.c1e82b0cf4d92cbc3d75.js" async=""></script><script src="/_next/static/chunks/pages/members/%5Bid%5D-f279413a3daf3c18264d.js" async=""></script><script src="/_next/static/RH7Qjj9bKzOmFDwPBbN9a/_buildManifest.js" async=""></script><script src="/_next/static/RH7Qjj9bKzOmFDwPBbN9a/_ssgManifest.js" async=""></script></body></html>